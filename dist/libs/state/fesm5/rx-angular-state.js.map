{"version":3,"file":"rx-angular-state.js","sources":["ng://@rx-angular/state/lib/core/utils/pipe-from-array.ts","ng://@rx-angular/state/lib/core/utils/typing.ts","ng://@rx-angular/state/lib/rxjs/operators/stateful.ts","ng://@rx-angular/state/lib/rxjs/operators/select.ts","ng://@rx-angular/state/lib/rxjs/operators/distinctUntilSomeChanged.ts","ng://@rx-angular/state/lib/rxjs/operators/selectSlice.ts","ng://@rx-angular/state/lib/core/accumulation-observable.ts","ng://@rx-angular/state/lib/core/side-effect-observable.ts","ng://@rx-angular/state/lib/rx-state.service.ts","ng://@rx-angular/state/rx-angular-state.ts"],"sourcesContent":["import { noop, UnaryFunction } from 'rxjs';\r\n\r\nexport function pipeFromArray<T, R>(\r\n  fns: Array<UnaryFunction<T, R>>\r\n): UnaryFunction<T, R> {\r\n  if (!fns) {\r\n    return noop as UnaryFunction<any, any>;\r\n  }\r\n\r\n  if (fns.length === 1) {\r\n    return fns[0];\r\n  }\r\n\r\n  return function piped(input: T): R {\r\n    return fns.reduce(\r\n      (prev: any, fn: UnaryFunction<T, R>) => fn(prev),\r\n      input as any\r\n    );\r\n  };\r\n}\r\n","import { OperatorFunction } from 'rxjs';\r\n\r\nexport function isPromiseGuard<T>(value: unknown): value is Promise<T> {\r\n  return (\r\n    !!value &&\r\n    typeof (<any>value).subscribe !== 'function' &&\r\n    typeof (value as any).then === 'function'\r\n  );\r\n}\r\n\r\nexport function isOperateFnArrayGuard<T, R = T>(\r\n  op: any[]\r\n): op is OperatorFunction<T, R>[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'function');\r\n}\r\n\r\nexport function isStringArrayGuard(op: any[]): op is string[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'string');\r\n}\r\n\r\nexport function isIterableGuard<T>(obj: unknown): obj is Array<T> {\r\n  if (obj === null || obj === undefined) {\r\n    return false;\r\n  }\r\n  return typeof (obj as any)[Symbol.iterator] === 'function';\r\n}\r\n\r\nexport function isKeyOf<O>(k: unknown): k is keyof O {\r\n  return (\r\n    !!k &&\r\n    (typeof k === 'string' || typeof k === 'symbol' || typeof k === 'number')\r\n  );\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged, filter, shareReplay } from 'rxjs/operators';\r\nimport { isOperateFnArrayGuard, pipeFromArray } from '../../core/utils';\r\n\r\n/**\r\n * @description\r\n *\r\n * As the name `stateful` implies this operator is useful when you process an Observable which maintains state.\r\n *\r\n * Maintaining state as an `Observable` source comes with a handful of repetitive as well as use case specific tasks.\r\n *\r\n * It acts like the Observables `pipe` method.\r\n * It accepts RxJS operators and composes them like `Observable#pipe` and the standalone `pipe` method.\r\n *\r\n * Furthermore, it takes care of the above mentioned repetitive tasks as listed below.\r\n *\r\n * You will always (aka repetitive) want to ensure that:\r\n * - only distinct state changes are emitted\r\n * - only defined values are emitted (filter out undefined, which ensures lazy state)\r\n * - share and replay custom operations for multiple subscribers (saves performance)\r\n *\r\n * You will sometimes (aka situational) need:\r\n * - a subset of the state (derivations)\r\n * - compose the state with other Observables or change the Observables behaviour\r\n *\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n * @return OperatorFunction<T, A>\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T>(): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n/**\r\n * @description\r\n *\r\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T, R>(\r\n  ...optionalDerive: OperatorFunction<T, R>[]\r\n): OperatorFunction<T, T | R> {\r\n  return (s: Observable<T>): Observable<T | R> => {\r\n    return s.pipe(\r\n      // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\r\n      // of data) @TODO evaluate benefits vs. overhead\r\n      distinctUntilChanged(),\r\n      // CUSTOM LOGIC HERE\r\n      (o: Observable<T>): Observable<T | R> => {\r\n        if (isOperateFnArrayGuard(optionalDerive)) {\r\n          return o.pipe(pipeFromArray(optionalDerive));\r\n        }\r\n        return o;\r\n      },\r\n      // initial emissions, undefined is no base-state, pollution with skip(1)\r\n      filter(v => v !== undefined),\r\n      // distinct same derivation value\r\n      distinctUntilChanged(),\r\n      // reuse custom operations result for multiple subscribers and reemit the last calculated value.\r\n      shareReplay({ bufferSize: 1, refCount: true })\r\n    );\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { pluck } from 'rxjs/operators';\r\nimport {\r\n  isOperateFnArrayGuard,\r\n  isStringArrayGuard,\r\n  pipeFromArray\r\n} from '../../core/utils';\r\nimport { stateful } from './stateful';\r\n\r\n/**\r\n * @description\r\n * returns the state as shared, replayed and distinct `Observable<T>`. This way you don't have to think about late\r\n * subscribers, multiple subscribers or multiple emissions of the same value.\r\n *\r\n * @example\r\n * const state$ = state.pipe(select());\r\n * state$.subscribe(state => doStuff(state));\r\n *\r\n * @returns Observable<T>\r\n */\r\n\r\nexport function select<T>(): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * @description\r\n * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n *\r\n * @example\r\n * const profilePicture$ = state.pipe(\r\n *   select(\r\n *    pluck('profilePicture'),\r\n *    switchMap(profilePicture => mapImageAsync(profilePicture))\r\n *   )\r\n * );\r\n * @param  { OperatorFunction<T, A> } op\r\n * @returns Observable<A>\r\n *\r\n * @docsPage select\r\n * @docsCategory operators\r\n */\r\nexport function select<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n\r\n/**\r\n * @description\r\n * Access a single property of the state by providing keys.\r\n * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n *\r\n * @example\r\n *  // Access a single property\r\n * const bar$ = state$.pipe(select('bar'));\r\n *\r\n * // Access a nested property\r\n * const foo$ = state$.pipe(select('bar', 'foo'));\r\n *\r\n * @return Observable<T[K1]>\r\n */\r\nexport function select<T, K1 extends keyof T>(\r\n  k1: K1\r\n): OperatorFunction<T, T[K1]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  k1: K1,\r\n  k2: K2\r\n): OperatorFunction<T, T[K1][K2]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2]\r\n>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3]\r\n>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4]\r\n>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]\r\n>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5,\r\n  k6: K6\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function select<T>(\r\n  ...opOrMapFn: OperatorFunction<T, any>[] | string[]\r\n): OperatorFunction<T, any> {\r\n  return (state$: Observable<T>) => {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    } else {\r\n      throw new Error('wrong params passed to select');\r\n    }\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\n\r\n/**\r\n * @internal\r\n */\r\nconst defaultCompare = <T, K extends keyof T>(oldVal: any, newVal: any) =>\r\n  oldVal === newVal;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * If properties of the source change, which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n * // An example comparing the first letters of just the name property.\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n * // compare the first letters of the name property\r\n * const customComparison: KeyCompareMap<Person> = {\r\n *   name: (oldName, newName) => oldName.substring(0, 3) === newName.substring(0, 3)\r\n * };\r\n *\r\n * of<Person>(\r\n *   { age: 4, name: 'Foo1'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo2'},\r\n *   { age: 6, name: 'Foo3'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(customComparison),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n *\r\n * @see {@link KeyCompareMap}\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\r\n * If properties of the source change which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n *\r\n * of(\r\n *   { age: 4, name: 'Foo'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo'},\r\n *   { age: 6, name: 'Foo'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(['age', 'name']),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo' }\r\n * // { age: 6, name: 'Foo' }\r\n *\r\n * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n * interface Person {\r\n *     age: number;\r\n *     name: string;\r\n *  }\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * of(\r\n *     { age: 4, name: 'Foo1'},\r\n *     { age: 7, name: 'Bar'},\r\n *     { age: 5, name: 'Foo2'},\r\n *     { age: 6, name: 'Foo3'},\r\n *   ).pipe(\r\n *     distinctUntilSomeChanged(['age', 'name'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n * // { age: 6, name: 'Foo3' }\r\n *\r\n * @param {K[]} keys String key for object property lookup on each item.\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * previous item in the source. (applied to each specified key)\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T> {\r\n  let distinctCompare: CompareFn<T>;\r\n  if (Array.isArray(keysOrMap)) {\r\n    const keys = keysOrMap;\r\n    const innerCompare: CompareFn<T[K]> = compare ? compare : defaultCompare;\r\n    distinctCompare = (oldState, newState) =>\r\n      keys.some(key => !innerCompare(oldState[key], newState[key]));\r\n  } else {\r\n    const keyComparatorMap = keysOrMap;\r\n    const innerCompare = (a: T[K], b: T[K], customCompFn?: CompareFn<T[K]>) =>\r\n      customCompFn ? customCompFn(a, b) : defaultCompare(a, b);\r\n    distinctCompare = (oldState, newState) => {\r\n      return Object.keys(keyComparatorMap).some(\r\n        key =>\r\n          !innerCompare(\r\n            (oldState as any)[key],\r\n            (newState as any)[key],\r\n            (keyComparatorMap as any)[key]\r\n          )\r\n      );\r\n    };\r\n  }\r\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\r\n}\r\n","import { Observable, OperatorFunction } from 'rxjs';\r\nimport { filter, map } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits a distinct subset of the received object.\r\n * You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n *\r\n * // Select title and panelOpen.\r\n * // compare the first letters of the `title` property and use the default comparison for `panelOpen`\r\n * const customComparison: KeyCompareMap<MyState> = {\r\n *   title: (oldTitle, newTitle) => oldTitle.substring(0, 3) === newTitle.substring(0, 3),\r\n *   panelOpen: undefined\r\n * };\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: false}\r\n * );\r\n * const viewModel$ = state$.pipe(\r\n *  selectSlice(customComparison),\r\n *  tap(console.log)\r\n * ).subscribe();\r\n *\r\n * // displays:\r\n * // { panelOpen: true, title: 'myTitle' }\r\n * // { panelOpen: true, title: 'newTitle' }\r\n * // { panelOpen: false, title: 'newTitle' }\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap* @docsPage selectSlice\r\n * @docsCategory operators\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\r\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\r\n * Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value\r\n *  should be emitted.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n * const state$: Observable<MyState> = of({\r\n *   title: 'myTitle',\r\n *   items: ['foo', 'bar'],\r\n *   panelOpen: true\r\n * });\r\n * const slice$ = state$.pipe(selectSlice(['items', 'panelOpen'])).pipe(tap(console.log)).subscribe();\r\n *\r\n * // displays:\r\n * // { items: ['foo', 'bar'], panelOpen: true }\r\n *\r\n * * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { selectSlices } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true}\r\n * )\r\n * .pipe(\r\n *     selectSlices(['title', 'items'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * //  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n * //  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n * //  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *\r\n * @param {(K)[]} keys - the array of keys which should be selected\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, R>;\r\n/**\r\n * @internal\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, Partial<T>> {\r\n  const keys = Array.isArray(keysOrMap)\r\n    ? keysOrMap\r\n    : (Object.keys(keysOrMap) as K[]);\r\n  const distinctOperator = Array.isArray(keysOrMap)\r\n    ? distinctUntilSomeChanged(keysOrMap, compare)\r\n    : distinctUntilSomeChanged(keysOrMap);\r\n\r\n  return (o$: Observable<T>): Observable<Partial<T>> =>\r\n    o$.pipe(\r\n      // to avoid emissions of empty objects map to present values and filter out emissions with no values present\r\n      map(state => ({\r\n        definedKeys: keys.filter(\r\n          k => state.hasOwnProperty(k) && state[k] !== undefined\r\n        ),\r\n        state\r\n      })),\r\n      filter(({ definedKeys, state }) => !!definedKeys.length),\r\n      // create view-model\r\n      map(({ definedKeys, state }) =>\r\n        definedKeys\r\n          .filter(k => state.hasOwnProperty(k) && state[k] !== undefined)\r\n          .reduce((vm, key) => {\r\n            vm[key] = state[key];\r\n            return vm;\r\n          }, {} as Partial<T>)\r\n      ),\r\n      // forward distinct values\r\n      distinctOperator\r\n    );\r\n}\r\n","import {\r\n  BehaviorSubject,\r\n  ConnectableObservable,\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport {\r\n  distinctUntilChanged,\r\n  mergeAll,\r\n  observeOn,\r\n  publish,\r\n  publishReplay,\r\n  scan,\r\n  tap,\r\n  withLatestFrom\r\n} from 'rxjs/operators';\r\n\r\nexport type AccumulationFn = <T>(st: T, sl: Partial<T>) => T;\r\n\r\nconst defaultAccumulator: AccumulationFn = <T>(st: T, sl: Partial<T>): T => {\r\n  return { ...st, ...sl };\r\n};\r\n\r\ninterface Accumulator<T> extends Subscribable<T> {\r\n  state: T;\r\n  state$: Observable<T>;\r\n  signal$: Observable<T>;\r\n  nextSlice: (stateSlice: Partial<T>) => void;\r\n  nextSliceObservable: (state$: Observable<Partial<T>>) => void;\r\n  nextAccumulator: (fn: AccumulationFn) => void;\r\n}\r\n\r\nexport function createAccumulationObservable<T extends object>(\r\n  stateObservables = new Subject<Observable<Partial<T>>>(),\r\n  stateSlices = new Subject<Partial<T>>(),\r\n  accumulatorObservable = new BehaviorSubject(defaultAccumulator)\r\n): Accumulator<T> {\r\n  const signal$ = merge(\r\n    stateObservables.pipe(\r\n      distinctUntilChanged(),\r\n      mergeAll(),\r\n      observeOn(queueScheduler)\r\n    ),\r\n    stateSlices.pipe(observeOn(queueScheduler))\r\n  ).pipe(\r\n    withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))),\r\n    scan(\r\n      (state, [slice, stateAccumulator]) => stateAccumulator(state, slice),\r\n      {} as T\r\n    ),\r\n    tap(newState => (compositionObservable.state = newState)),\r\n    publish()\r\n  );\r\n  const state$: Observable<T> = signal$.pipe(publishReplay(1));\r\n  const compositionObservable: Accumulator<T> = {\r\n    state: {} as T,\r\n    signal$,\r\n    state$,\r\n    nextSlice,\r\n    nextSliceObservable,\r\n    nextAccumulator,\r\n    subscribe\r\n  };\r\n\r\n  // ======\r\n\r\n  return compositionObservable;\r\n\r\n  // ======\r\n\r\n  function nextAccumulator(accumulatorFn: AccumulationFn): void {\r\n    accumulatorObservable.next(accumulatorFn);\r\n  }\r\n\r\n  function nextSlice(stateSlice: Partial<T>): void {\r\n    stateSlices.next(stateSlice);\r\n  }\r\n\r\n  function nextSliceObservable(stateObservable: Observable<Partial<T>>): void {\r\n    stateObservables.next(stateObservable);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    const sub = (compositionObservable.signal$ as ConnectableObservable<\r\n      T\r\n    >).connect();\r\n    sub.add(\r\n      (compositionObservable.state$ as ConnectableObservable<T>).connect()\r\n    );\r\n    return sub;\r\n  }\r\n}\r\n","import {\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport { mergeAll, observeOn } from 'rxjs/operators';\r\n\r\nexport function createSideEffectObservable<T>(\r\n  stateObservables = new Subject<Observable<T>>()\r\n): {\r\n  effects$: Observable<T>;\r\n  nextEffectObservable: (effect$: Observable<T>) => void;\r\n} & Subscribable<T> {\r\n  const effects$: Observable<T> = merge(\r\n    stateObservables.pipe(mergeAll(), observeOn(queueScheduler))\r\n  );\r\n\r\n  function nextEffectObservable(effect$: Observable<T>): void {\r\n    stateObservables.next(effect$);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    return effects$.subscribe();\r\n  }\r\n\r\n  return {\r\n    effects$,\r\n    nextEffectObservable,\r\n    subscribe\r\n  };\r\n}\r\n","import { Injectable, OnDestroy } from '@angular/core';\r\nimport {\r\n  isObservable,\r\n  Observable,\r\n  OperatorFunction,\r\n  Subscribable,\r\n  Subscription,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport {\r\n  createAccumulationObservable,\r\n  createSideEffectObservable,\r\n  isOperateFnArrayGuard,\r\n  isStringArrayGuard,\r\n  pipeFromArray,\r\n  stateful,\r\n  isKeyOf,\r\n  AccumulationFn\r\n} from './core';\r\nimport { filter, map, pluck, tap } from 'rxjs/operators';\r\n\r\ntype ProjectStateFn<T> = (oldState: T) => Partial<T>;\r\ntype ProjectValueFn<T, K extends keyof T> = (oldState: T) => T[K];\r\n\r\ntype ProjectStateReducer<T, V> = (oldState: T, value: V) => Partial<T>;\r\n\r\ntype ProjectValueReducer<T, K extends keyof T, V> = (\r\n  oldState: T,\r\n  value: V\r\n) => T[K];\r\n\r\n/**\r\n * @description\r\n * RxState is a light-weight reactive state management service for managing local state in angular.\r\n *\r\n * ![state logo](https://raw.githubusercontent.com/BioPhoton/rx-angular/master/libs/state/images/state_logo.png)\r\n *\r\n * @example\r\n * Component({\r\n *   selector: 'app-stateful',\r\n *   template: `<div>{{ state$ | async | json }}</div>`,\r\n *   providers: [RxState]\r\n * })\r\n * export class StatefulComponent {\r\n *   readonly state$ = this.state.select();\r\n *\r\n *   constructor(private state: RxState<{ foo: string }>) {}\r\n * }\r\n *\r\n * @docsCategory RxState\r\n * @docsPage RxState\r\n */\r\n@Injectable()\r\nexport class RxState<T extends object> implements OnDestroy, Subscribable<T> {\r\n  private subscription = new Subscription();\r\n\r\n  private accumulator = createAccumulationObservable<T>();\r\n  private effectObservable = createSideEffectObservable();\r\n\r\n  /**\r\n   * @description\r\n   * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.\r\n   * Use the `$` property if you want to read the state without having applied {@link stateful} to it.\r\n   */\r\n  readonly $: Observable<T> = this.accumulator.signal$;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor() {\r\n    this.subscription.add(this.subscribe());\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  ngOnDestroy(): void {\r\n    this.subscription.unsubscribe();\r\n  }\r\n\r\n  setAccumulator(accumulatorFn: AccumulationFn) {\r\n    this.accumulator.nextAccumulator(accumulatorFn);\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Read from the state in imperative manner. Returns the state object in its current state.\r\n   *\r\n   * @example\r\n   * const { disabled } = state.get();\r\n   * if (!disabled) {\r\n   *   doStuff();\r\n   * }\r\n   *\r\n   * @return T\r\n   */\r\n  get(): T {\r\n    return this.accumulator.state;\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate one or many properties of the state by providing a `Partial<T>` state or a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * // Update one or many properties of the state by providing a `Partial<T>`\r\n   *\r\n   * const partialState = {\r\n   *   foo: 'bar',\r\n   *   bar: 5\r\n   * };\r\n   * state.set(partialState);\r\n   *\r\n   * // Update one or many properties of the state by providing a `ProjectionFunction<T>`\r\n   *\r\n   * const reduceFn = oldState => ({\r\n   *   bar: oldState.bar + 5\r\n   * });\r\n   * state.set(reduceFn);\r\n   *\r\n   * @param {Partial<T>|ProjectStateFn<T>} stateOrProjectState\r\n   * @return void\r\n   */\r\n  set(stateOrProjectState: Partial<T> | ProjectStateFn<T>): void;\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate a single property of the state by the property name and a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * const reduceFn = oldState => oldState.bar + 5;\r\n   * state.set('bar', reduceFn);\r\n   *\r\n   * @param {K} key\r\n   * @param {ProjectValueFn<T, K>} projectSlice\r\n   * @return void\r\n   */\r\n  set<K extends keyof T, O>(key: K, projectSlice: ProjectValueFn<T, K>): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  set<K extends keyof T>(\r\n    keyOrStateOrProjectState: Partial<T> | ProjectStateFn<T> | K,\r\n    stateOrSliceProjectFn?: ProjectValueFn<T, K>\r\n  ): void {\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'object' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(keyOrStateOrProjectState);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'function' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(\r\n        keyOrStateOrProjectState(this.accumulator.state)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrStateOrProjectState) &&\r\n      typeof stateOrSliceProjectFn === 'function'\r\n    ) {\r\n      const state: Partial<T> = {};\r\n      state[keyOrStateOrProjectState] = stateOrSliceProjectFn(\r\n        this.accumulator.state\r\n      );\r\n      this.accumulator.nextSlice(state);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to set');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Connect an `Observable<Partial<T>>` to the state `T`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\r\n   *\r\n   * // Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\r\n   *\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\r\n   * // 5 due to the projectionFunction\r\n   */\r\n  connect<V>(\r\n    inputOrSlice$: Observable<Partial<T> | V>,\r\n    projectFn?: ProjectStateReducer<T, V>\r\n  ): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<T[K]>` source to a specific property `K` in the state `T`. Any emitted change will update\r\n   * this\r\n   * specific property in the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T>(key: K, slice$: Observable<T[K]>): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<V>` source to a specific property in the state. Additionally you can provide a\r\n   * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$, (state, timerChange) => state.timer += timerChange);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    key: K,\r\n    input$: Observable<V>,\r\n    projectSliceFn: ProjectValueReducer<T, K, V>\r\n  ): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    keyOrInputOrSlice$: K | Observable<Partial<T> | V>,\r\n    projectOrSlices$?: ProjectStateReducer<T, V> | Observable<T[K]>,\r\n    projectValueFn?: ProjectValueReducer<T, K, V>\r\n  ): void {\r\n    if (\r\n      isObservable<Partial<T>>(keyOrInputOrSlice$) &&\r\n      projectOrSlices$ === undefined &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined)\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isObservable<V>(keyOrInputOrSlice$) &&\r\n      typeof projectOrSlices$ === 'function' &&\r\n      !isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const project = projectOrSlices$;\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(v => project(this.get(), v))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: value }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<V>(projectOrSlices$) &&\r\n      typeof projectValueFn === 'function'\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: projectValueFn(this.get(), value) }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to connect');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<T>`. This way you don't have to think about **late\r\n   * subscribers**,\r\n   * **multiple subscribers** or **multiple emissions** of the same value\r\n   *\r\n   * @example\r\n   * const state$ = state.select();\r\n   * state$.subscribe(state => doStuff(state));\r\n   *\r\n   * @returns Observable<T>\r\n   */\r\n  select(): Observable<T>;\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n   * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n   *\r\n   * @example\r\n   * const profilePicture$ = state.select(\r\n   *  pluck('profilePicture'),\r\n   *  switchMap(profilePicture => mapImageAsync(profilePicture))\r\n   * );\r\n   * @param op { OperatorFunction<T, A> }\r\n   * @returns Observable<A>\r\n   */\r\n  select<A = T>(op: OperatorFunction<T, A>): Observable<A>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>\r\n  ): Observable<B>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>\r\n  ): Observable<C>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>\r\n  ): Observable<D>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C, E = D>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>\r\n  ): Observable<E>;\r\n  /**\r\n   * @description\r\n   * Access a single property of the state by providing keys.\r\n   * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n   *\r\n   * @example\r\n   * // Access a single property\r\n   *\r\n   * const bar$ = state.select('bar');\r\n   *\r\n   * // Access a nested property\r\n   *\r\n   * const foo$ = state.select('bar', 'foo');\r\n   *\r\n   * @return Observable<T[K1]>\r\n   */\r\n  select<K1 extends keyof T>(k1: K1): Observable<T[K1]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T, K2 extends keyof T[K1]>(\r\n    k1: K1,\r\n    k2: K2\r\n  ): Observable<T[K1][K2]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2]\r\n  >(k1: K1, k2: K2, k3: K3): Observable<T[K1][K2][K3]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4): Observable<T[K1][K2][K3][K4]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): Observable<T[K1][K2][K3][K4][K5]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4],\r\n    K6 extends keyof T[K1][K2][K3][K4][K5]\r\n  >(\r\n    k1: K1,\r\n    k2: K2,\r\n    k3: K3,\r\n    k4: K4,\r\n    k5: K5,\r\n    k6: K6\r\n  ): Observable<T[K1][K2][K3][K4][K5][K6]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<R>(\r\n    ...opOrMapFn: OperatorFunction<T, R>[] | string[]\r\n  ): Observable<T | R> {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return this.accumulator.state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    }\r\n    throw new Error('wrong params passed to select');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional\r\n   * `sideEffectFunction`.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * // Directly pass an observable side-effect\r\n   * const localStorageEffect$ = changes$.pipe(\r\n   *  tap(changes => storeChanges(changes))\r\n   * );\r\n   * state.hold(localStorageEffect$);\r\n   *\r\n   * // Pass an additional `sideEffectFunction`\r\n   *\r\n   * const localStorageEffectFn = changes => storeChanges(changes);\r\n   * state.hold(changes$, localStorageEffectFn);\r\n   *\r\n   * @param {Observable<S>} obsOrObsWithSideEffect\r\n   * @param {function} [sideEffectFn]\r\n   */\r\n  hold<S>(\r\n    obsOrObsWithSideEffect: Observable<S>,\r\n    sideEffectFn?: (arg: S) => void\r\n  ): void {\r\n    if (typeof sideEffectFn === 'function') {\r\n      this.effectObservable.nextEffectObservable(\r\n        obsOrObsWithSideEffect.pipe(tap(sideEffectFn))\r\n      );\r\n      return;\r\n    }\r\n    this.effectObservable.nextEffectObservable(obsOrObsWithSideEffect);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  subscribe(): Unsubscribable {\r\n    const subscription = new Subscription();\r\n    subscription.add(this.accumulator.subscribe());\r\n    subscription.add(this.effectObservable.subscribe());\r\n    return subscription;\r\n  }\r\n}\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}