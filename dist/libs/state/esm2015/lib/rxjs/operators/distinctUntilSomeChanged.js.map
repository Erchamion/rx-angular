{"version":3,"file":"distinctUntilSomeChanged.js","sourceRoot":"ng://@rx-angular/state/","sources":["lib/rxjs/operators/distinctUntilSomeChanged.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AAGtD;;GAEG;AACH,MAAM,cAAc,GAAG,CAAuB,MAAW,EAAE,MAAW,EAAE,EAAE,CACxE,MAAM,KAAK,MAAM,CAAC;;AAoIpB;;GAEG;AACH,MAAM,UAAU,wBAAwB,CACtC,SAAiC,EACjC,OAAyB;IAEzB,IAAI,eAA6B,CAAC;IAClC,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;QAC5B,MAAM,IAAI,GAAG,SAAS,CAAC;QACvB,MAAM,YAAY,GAAoB,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,cAAc,CAAC;QACzE,eAAe,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,CACvC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;KACjE;SAAM;QACL,MAAM,gBAAgB,GAAG,SAAS,CAAC;QACnC,MAAM,YAAY,GAAG,CAAC,CAAO,EAAE,CAAO,EAAE,YAA8B,EAAE,EAAE,CACxE,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3D,eAAe,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE;YACvC,OAAO,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,CACvC,GAAG,CAAC,EAAE,CACJ,CAAC,YAAY,CACV,QAAgB,CAAC,GAAG,CAAC,EACrB,QAAgB,CAAC,GAAG,CAAC,EACrB,gBAAwB,CAAC,GAAG,CAAC,CAC/B,CACJ,CAAC;QACJ,CAAC,CAAC;KACH;IACD,OAAO,oBAAoB,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AAC5E,CAAC","sourcesContent":["import { MonoTypeOperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\n\r\n/**\r\n * @internal\r\n */\r\nconst defaultCompare = <T, K extends keyof T>(oldVal: any, newVal: any) =>\r\n  oldVal === newVal;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * If properties of the source change, which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n * // An example comparing the first letters of just the name property.\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n * // compare the first letters of the name property\r\n * const customComparison: KeyCompareMap<Person> = {\r\n *   name: (oldName, newName) => oldName.substring(0, 3) === newName.substring(0, 3)\r\n * };\r\n *\r\n * of<Person>(\r\n *   { age: 4, name: 'Foo1'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo2'},\r\n *   { age: 6, name: 'Foo3'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(customComparison),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n *\r\n * @see {@link KeyCompareMap}\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\r\n * If properties of the source change which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n *\r\n * of(\r\n *   { age: 4, name: 'Foo'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo'},\r\n *   { age: 6, name: 'Foo'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(['age', 'name']),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo' }\r\n * // { age: 6, name: 'Foo' }\r\n *\r\n * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n * interface Person {\r\n *     age: number;\r\n *     name: string;\r\n *  }\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * of(\r\n *     { age: 4, name: 'Foo1'},\r\n *     { age: 7, name: 'Bar'},\r\n *     { age: 5, name: 'Foo2'},\r\n *     { age: 6, name: 'Foo3'},\r\n *   ).pipe(\r\n *     distinctUntilSomeChanged(['age', 'name'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n * // { age: 6, name: 'Foo3' }\r\n *\r\n * @param {K[]} keys String key for object property lookup on each item.\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * previous item in the source. (applied to each specified key)\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T> {\r\n  let distinctCompare: CompareFn<T>;\r\n  if (Array.isArray(keysOrMap)) {\r\n    const keys = keysOrMap;\r\n    const innerCompare: CompareFn<T[K]> = compare ? compare : defaultCompare;\r\n    distinctCompare = (oldState, newState) =>\r\n      keys.some(key => !innerCompare(oldState[key], newState[key]));\r\n  } else {\r\n    const keyComparatorMap = keysOrMap;\r\n    const innerCompare = (a: T[K], b: T[K], customCompFn?: CompareFn<T[K]>) =>\r\n      customCompFn ? customCompFn(a, b) : defaultCompare(a, b);\r\n    distinctCompare = (oldState, newState) => {\r\n      return Object.keys(keyComparatorMap).some(\r\n        key =>\r\n          !innerCompare(\r\n            (oldState as any)[key],\r\n            (newState as any)[key],\r\n            (keyComparatorMap as any)[key]\r\n          )\r\n      );\r\n    };\r\n  }\r\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\r\n}\r\n"]}