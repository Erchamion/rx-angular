{"version":3,"file":"selectSlice.js","sourceRoot":"ng://@rx-angular/state/","sources":["lib/rxjs/operators/selectSlice.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;AAE7C,OAAO,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAsHtE;;GAEG;AACH,MAAM,UAAU,WAAW,CACzB,SAAiC,EACjC,OAAyB;IAEzB,MAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;QACnC,CAAC,CAAC,SAAS;QACX,CAAC,CAAE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAS,CAAC;IACpC,MAAM,gBAAgB,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;QAC/C,CAAC,CAAC,wBAAwB,CAAC,SAAS,EAAE,OAAO,CAAC;QAC9C,CAAC,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;IAExC,OAAO,CAAC,EAAiB,EAA0B,EAAE,CACnD,EAAE,CAAC,IAAI;IACL,4GAA4G;IAC5G,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QACZ,WAAW,EAAE,IAAI,CAAC,MAAM,CACtB,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,SAAS,CACvD;QACD,KAAK;KACN,CAAC,CAAC,EACH,MAAM,CAAC,CAAC,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC;IACxD,oBAAoB;IACpB,GAAG,CAAC,CAAC,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,CAC7B,WAAW;SACR,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;SAC9D,MAAM,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE;QAClB,EAAE,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;QACrB,OAAO,EAAE,CAAC;IACZ,CAAC,EAAE,EAAgB,CAAC,CACvB;IACD,0BAA0B;IAC1B,gBAAgB,CACjB,CAAC;AACN,CAAC","sourcesContent":["import { Observable, OperatorFunction } from 'rxjs';\r\nimport { filter, map } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits a distinct subset of the received object.\r\n * You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n *\r\n * // Select title and panelOpen.\r\n * // compare the first letters of the `title` property and use the default comparison for `panelOpen`\r\n * const customComparison: KeyCompareMap<MyState> = {\r\n *   title: (oldTitle, newTitle) => oldTitle.substring(0, 3) === newTitle.substring(0, 3),\r\n *   panelOpen: undefined\r\n * };\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: false}\r\n * );\r\n * const viewModel$ = state$.pipe(\r\n *  selectSlice(customComparison),\r\n *  tap(console.log)\r\n * ).subscribe();\r\n *\r\n * // displays:\r\n * // { panelOpen: true, title: 'myTitle' }\r\n * // { panelOpen: true, title: 'newTitle' }\r\n * // { panelOpen: false, title: 'newTitle' }\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap* @docsPage selectSlice\r\n * @docsCategory operators\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\r\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\r\n * Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value\r\n *  should be emitted.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n * const state$: Observable<MyState> = of({\r\n *   title: 'myTitle',\r\n *   items: ['foo', 'bar'],\r\n *   panelOpen: true\r\n * });\r\n * const slice$ = state$.pipe(selectSlice(['items', 'panelOpen'])).pipe(tap(console.log)).subscribe();\r\n *\r\n * // displays:\r\n * // { items: ['foo', 'bar'], panelOpen: true }\r\n *\r\n * * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { selectSlices } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true}\r\n * )\r\n * .pipe(\r\n *     selectSlices(['title', 'items'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * //  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n * //  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n * //  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *\r\n * @param {(K)[]} keys - the array of keys which should be selected\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, R>;\r\n/**\r\n * @internal\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, Partial<T>> {\r\n  const keys = Array.isArray(keysOrMap)\r\n    ? keysOrMap\r\n    : (Object.keys(keysOrMap) as K[]);\r\n  const distinctOperator = Array.isArray(keysOrMap)\r\n    ? distinctUntilSomeChanged(keysOrMap, compare)\r\n    : distinctUntilSomeChanged(keysOrMap);\r\n\r\n  return (o$: Observable<T>): Observable<Partial<T>> =>\r\n    o$.pipe(\r\n      // to avoid emissions of empty objects map to present values and filter out emissions with no values present\r\n      map(state => ({\r\n        definedKeys: keys.filter(\r\n          k => state.hasOwnProperty(k) && state[k] !== undefined\r\n        ),\r\n        state\r\n      })),\r\n      filter(({ definedKeys, state }) => !!definedKeys.length),\r\n      // create view-model\r\n      map(({ definedKeys, state }) =>\r\n        definedKeys\r\n          .filter(k => state.hasOwnProperty(k) && state[k] !== undefined)\r\n          .reduce((vm, key) => {\r\n            vm[key] = state[key];\r\n            return vm;\r\n          }, {} as Partial<T>)\r\n      ),\r\n      // forward distinct values\r\n      distinctOperator\r\n    );\r\n}\r\n"]}