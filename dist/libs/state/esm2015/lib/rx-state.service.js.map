{"version":3,"file":"rx-state.service.js","sourceRoot":"ng://@rx-angular/state/","sources":["lib/rx-state.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable, OnDestroy } from '@angular/core';\r\nimport {\r\n  isObservable,\r\n  Observable,\r\n  OperatorFunction,\r\n  Subscribable,\r\n  Subscription,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport {\r\n  createAccumulationObservable,\r\n  createSideEffectObservable,\r\n  isOperateFnArrayGuard,\r\n  isStringArrayGuard,\r\n  pipeFromArray,\r\n  stateful,\r\n  isKeyOf,\r\n  AccumulationFn\r\n} from './core';\r\nimport { filter, map, pluck, tap } from 'rxjs/operators';\r\n\r\ntype ProjectStateFn<T> = (oldState: T) => Partial<T>;\r\ntype ProjectValueFn<T, K extends keyof T> = (oldState: T) => T[K];\r\n\r\ntype ProjectStateReducer<T, V> = (oldState: T, value: V) => Partial<T>;\r\n\r\ntype ProjectValueReducer<T, K extends keyof T, V> = (\r\n  oldState: T,\r\n  value: V\r\n) => T[K];\r\n\r\n/**\r\n * @description\r\n * RxState is a light-weight reactive state management service for managing local state in angular.\r\n *\r\n * ![state logo](https://raw.githubusercontent.com/BioPhoton/rx-angular/master/libs/state/images/state_logo.png)\r\n *\r\n * @example\r\n * Component({\r\n *   selector: 'app-stateful',\r\n *   template: `<div>{{ state$ | async | json }}</div>`,\r\n *   providers: [RxState]\r\n * })\r\n * export class StatefulComponent {\r\n *   readonly state$ = this.state.select();\r\n *\r\n *   constructor(private state: RxState<{ foo: string }>) {}\r\n * }\r\n *\r\n * @docsCategory RxState\r\n * @docsPage RxState\r\n */\r\n@Injectable()\r\nexport class RxState<T extends object> implements OnDestroy, Subscribable<T> {\r\n  private subscription = new Subscription();\r\n\r\n  private accumulator = createAccumulationObservable<T>();\r\n  private effectObservable = createSideEffectObservable();\r\n\r\n  /**\r\n   * @description\r\n   * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.\r\n   * Use the `$` property if you want to read the state without having applied {@link stateful} to it.\r\n   */\r\n  readonly $: Observable<T> = this.accumulator.signal$;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor() {\r\n    this.subscription.add(this.subscribe());\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  ngOnDestroy(): void {\r\n    this.subscription.unsubscribe();\r\n  }\r\n\r\n  setAccumulator(accumulatorFn: AccumulationFn) {\r\n    this.accumulator.nextAccumulator(accumulatorFn);\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Read from the state in imperative manner. Returns the state object in its current state.\r\n   *\r\n   * @example\r\n   * const { disabled } = state.get();\r\n   * if (!disabled) {\r\n   *   doStuff();\r\n   * }\r\n   *\r\n   * @return T\r\n   */\r\n  get(): T {\r\n    return this.accumulator.state;\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate one or many properties of the state by providing a `Partial<T>` state or a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * // Update one or many properties of the state by providing a `Partial<T>`\r\n   *\r\n   * const partialState = {\r\n   *   foo: 'bar',\r\n   *   bar: 5\r\n   * };\r\n   * state.set(partialState);\r\n   *\r\n   * // Update one or many properties of the state by providing a `ProjectionFunction<T>`\r\n   *\r\n   * const reduceFn = oldState => ({\r\n   *   bar: oldState.bar + 5\r\n   * });\r\n   * state.set(reduceFn);\r\n   *\r\n   * @param {Partial<T>|ProjectStateFn<T>} stateOrProjectState\r\n   * @return void\r\n   */\r\n  set(stateOrProjectState: Partial<T> | ProjectStateFn<T>): void;\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate a single property of the state by the property name and a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * const reduceFn = oldState => oldState.bar + 5;\r\n   * state.set('bar', reduceFn);\r\n   *\r\n   * @param {K} key\r\n   * @param {ProjectValueFn<T, K>} projectSlice\r\n   * @return void\r\n   */\r\n  set<K extends keyof T, O>(key: K, projectSlice: ProjectValueFn<T, K>): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  set<K extends keyof T>(\r\n    keyOrStateOrProjectState: Partial<T> | ProjectStateFn<T> | K,\r\n    stateOrSliceProjectFn?: ProjectValueFn<T, K>\r\n  ): void {\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'object' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(keyOrStateOrProjectState);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'function' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(\r\n        keyOrStateOrProjectState(this.accumulator.state)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrStateOrProjectState) &&\r\n      typeof stateOrSliceProjectFn === 'function'\r\n    ) {\r\n      const state: Partial<T> = {};\r\n      state[keyOrStateOrProjectState] = stateOrSliceProjectFn(\r\n        this.accumulator.state\r\n      );\r\n      this.accumulator.nextSlice(state);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to set');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Connect an `Observable<Partial<T>>` to the state `T`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\r\n   *\r\n   * // Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\r\n   *\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\r\n   * // 5 due to the projectionFunction\r\n   */\r\n  connect<V>(\r\n    inputOrSlice$: Observable<Partial<T> | V>,\r\n    projectFn?: ProjectStateReducer<T, V>\r\n  ): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<T[K]>` source to a specific property `K` in the state `T`. Any emitted change will update\r\n   * this\r\n   * specific property in the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T>(key: K, slice$: Observable<T[K]>): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<V>` source to a specific property in the state. Additionally you can provide a\r\n   * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$, (state, timerChange) => state.timer += timerChange);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    key: K,\r\n    input$: Observable<V>,\r\n    projectSliceFn: ProjectValueReducer<T, K, V>\r\n  ): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    keyOrInputOrSlice$: K | Observable<Partial<T> | V>,\r\n    projectOrSlices$?: ProjectStateReducer<T, V> | Observable<T[K]>,\r\n    projectValueFn?: ProjectValueReducer<T, K, V>\r\n  ): void {\r\n    if (\r\n      isObservable<Partial<T>>(keyOrInputOrSlice$) &&\r\n      projectOrSlices$ === undefined &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined)\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isObservable<V>(keyOrInputOrSlice$) &&\r\n      typeof projectOrSlices$ === 'function' &&\r\n      !isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const project = projectOrSlices$;\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(v => project(this.get(), v))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: value }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<V>(projectOrSlices$) &&\r\n      typeof projectValueFn === 'function'\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: projectValueFn(this.get(), value) }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to connect');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<T>`. This way you don't have to think about **late\r\n   * subscribers**,\r\n   * **multiple subscribers** or **multiple emissions** of the same value\r\n   *\r\n   * @example\r\n   * const state$ = state.select();\r\n   * state$.subscribe(state => doStuff(state));\r\n   *\r\n   * @returns Observable<T>\r\n   */\r\n  select(): Observable<T>;\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n   * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n   *\r\n   * @example\r\n   * const profilePicture$ = state.select(\r\n   *  pluck('profilePicture'),\r\n   *  switchMap(profilePicture => mapImageAsync(profilePicture))\r\n   * );\r\n   * @param op { OperatorFunction<T, A> }\r\n   * @returns Observable<A>\r\n   */\r\n  select<A = T>(op: OperatorFunction<T, A>): Observable<A>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>\r\n  ): Observable<B>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>\r\n  ): Observable<C>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>\r\n  ): Observable<D>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C, E = D>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>\r\n  ): Observable<E>;\r\n  /**\r\n   * @description\r\n   * Access a single property of the state by providing keys.\r\n   * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n   *\r\n   * @example\r\n   * // Access a single property\r\n   *\r\n   * const bar$ = state.select('bar');\r\n   *\r\n   * // Access a nested property\r\n   *\r\n   * const foo$ = state.select('bar', 'foo');\r\n   *\r\n   * @return Observable<T[K1]>\r\n   */\r\n  select<K1 extends keyof T>(k1: K1): Observable<T[K1]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T, K2 extends keyof T[K1]>(\r\n    k1: K1,\r\n    k2: K2\r\n  ): Observable<T[K1][K2]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2]\r\n  >(k1: K1, k2: K2, k3: K3): Observable<T[K1][K2][K3]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4): Observable<T[K1][K2][K3][K4]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): Observable<T[K1][K2][K3][K4][K5]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4],\r\n    K6 extends keyof T[K1][K2][K3][K4][K5]\r\n  >(\r\n    k1: K1,\r\n    k2: K2,\r\n    k3: K3,\r\n    k4: K4,\r\n    k5: K5,\r\n    k6: K6\r\n  ): Observable<T[K1][K2][K3][K4][K5][K6]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<R>(\r\n    ...opOrMapFn: OperatorFunction<T, R>[] | string[]\r\n  ): Observable<T | R> {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return this.accumulator.state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    }\r\n    throw new Error('wrong params passed to select');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional\r\n   * `sideEffectFunction`.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * // Directly pass an observable side-effect\r\n   * const localStorageEffect$ = changes$.pipe(\r\n   *  tap(changes => storeChanges(changes))\r\n   * );\r\n   * state.hold(localStorageEffect$);\r\n   *\r\n   * // Pass an additional `sideEffectFunction`\r\n   *\r\n   * const localStorageEffectFn = changes => storeChanges(changes);\r\n   * state.hold(changes$, localStorageEffectFn);\r\n   *\r\n   * @param {Observable<S>} obsOrObsWithSideEffect\r\n   * @param {function} [sideEffectFn]\r\n   */\r\n  hold<S>(\r\n    obsOrObsWithSideEffect: Observable<S>,\r\n    sideEffectFn?: (arg: S) => void\r\n  ): void {\r\n    if (typeof sideEffectFn === 'function') {\r\n      this.effectObservable.nextEffectObservable(\r\n        obsOrObsWithSideEffect.pipe(tap(sideEffectFn))\r\n      );\r\n      return;\r\n    }\r\n    this.effectObservable.nextEffectObservable(obsOrObsWithSideEffect);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  subscribe(): Unsubscribable {\r\n    const subscription = new Subscription();\r\n    subscription.add(this.accumulator.subscribe());\r\n    subscription.add(this.effectObservable.subscribe());\r\n    return subscription;\r\n  }\r\n}\r\n"]}