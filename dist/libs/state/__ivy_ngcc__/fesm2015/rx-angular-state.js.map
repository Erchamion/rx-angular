{"version":3,"file":"rx-angular-state.js","sources":["ng:/@rx-angular/state/lib/core/utils/pipe-from-array.ts","ng:/@rx-angular/state/lib/core/utils/typing.ts","ng:/@rx-angular/state/lib/rxjs/operators/stateful.ts","ng:/@rx-angular/state/lib/rxjs/operators/select.ts","ng:/@rx-angular/state/lib/rxjs/operators/distinctUntilSomeChanged.ts","ng:/@rx-angular/state/lib/rxjs/operators/selectSlice.ts","ng:/@rx-angular/state/lib/core/accumulation-observable.ts","ng:/@rx-angular/state/lib/core/side-effect-observable.ts","ng:/@rx-angular/state/lib/rx-state.service.ts","ng:/@rx-angular/state/rx-angular-state.ts"],"names":[],"mappings":"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","sourcesContent":["import { noop, UnaryFunction } from 'rxjs';\r\n\r\nexport function pipeFromArray<T, R>(\r\n  fns: Array<UnaryFunction<T, R>>\r\n): UnaryFunction<T, R> {\r\n  if (!fns) {\r\n    return noop as UnaryFunction<any, any>;\r\n  }\r\n\r\n  if (fns.length === 1) {\r\n    return fns[0];\r\n  }\r\n\r\n  return function piped(input: T): R {\r\n    return fns.reduce(\r\n      (prev: any, fn: UnaryFunction<T, R>) => fn(prev),\r\n      input as any\r\n    );\r\n  };\r\n}\r\n","import { OperatorFunction } from 'rxjs';\r\n\r\nexport function isPromiseGuard<T>(value: unknown): value is Promise<T> {\r\n  return (\r\n    !!value &&\r\n    typeof (<any>value).subscribe !== 'function' &&\r\n    typeof (value as any).then === 'function'\r\n  );\r\n}\r\n\r\nexport function isOperateFnArrayGuard<T, R = T>(\r\n  op: any[]\r\n): op is OperatorFunction<T, R>[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'function');\r\n}\r\n\r\nexport function isStringArrayGuard(op: any[]): op is string[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'string');\r\n}\r\n\r\nexport function isIterableGuard<T>(obj: unknown): obj is Array<T> {\r\n  if (obj === null || obj === undefined) {\r\n    return false;\r\n  }\r\n  return typeof (obj as any)[Symbol.iterator] === 'function';\r\n}\r\n\r\nexport function isKeyOf<O>(k: unknown): k is keyof O {\r\n  return (\r\n    !!k &&\r\n    (typeof k === 'string' || typeof k === 'symbol' || typeof k === 'number')\r\n  );\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged, filter, shareReplay } from 'rxjs/operators';\r\nimport { isOperateFnArrayGuard, pipeFromArray } from '../../core/utils';\r\n\r\n/**\r\n * @description\r\n *\r\n * As the name `stateful` implies this operator is useful when you process an Observable which maintains state.\r\n *\r\n * Maintaining state as an `Observable` source comes with a handful of repetitive as well as use case specific tasks.\r\n *\r\n * It acts like the Observables `pipe` method.\r\n * It accepts RxJS operators and composes them like `Observable#pipe` and the standalone `pipe` method.\r\n *\r\n * Furthermore, it takes care of the above mentioned repetitive tasks as listed below.\r\n *\r\n * You will always (aka repetitive) want to ensure that:\r\n * - only distinct state changes are emitted\r\n * - only defined values are emitted (filter out undefined, which ensures lazy state)\r\n * - share and replay custom operations for multiple subscribers (saves performance)\r\n *\r\n * You will sometimes (aka situational) need:\r\n * - a subset of the state (derivations)\r\n * - compose the state with other Observables or change the Observables behaviour\r\n *\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n * @return OperatorFunction<T, A>\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T>(): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n/**\r\n * @description\r\n *\r\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T, R>(\r\n  ...optionalDerive: OperatorFunction<T, R>[]\r\n): OperatorFunction<T, T | R> {\r\n  return (s: Observable<T>): Observable<T | R> => {\r\n    return s.pipe(\r\n      // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\r\n      // of data) @TODO evaluate benefits vs. overhead\r\n      distinctUntilChanged(),\r\n      // CUSTOM LOGIC HERE\r\n      (o: Observable<T>): Observable<T | R> => {\r\n        if (isOperateFnArrayGuard(optionalDerive)) {\r\n          return o.pipe(pipeFromArray(optionalDerive));\r\n        }\r\n        return o;\r\n      },\r\n      // initial emissions, undefined is no base-state, pollution with skip(1)\r\n      filter(v => v !== undefined),\r\n      // distinct same derivation value\r\n      distinctUntilChanged(),\r\n      // reuse custom operations result for multiple subscribers and reemit the last calculated value.\r\n      shareReplay({ bufferSize: 1, refCount: true })\r\n    );\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { pluck } from 'rxjs/operators';\r\nimport {\r\n  isOperateFnArrayGuard,\r\n  isStringArrayGuard,\r\n  pipeFromArray\r\n} from '../../core/utils';\r\nimport { stateful } from './stateful';\r\n\r\n/**\r\n * @description\r\n * returns the state as shared, replayed and distinct `Observable<T>`. This way you don't have to think about late\r\n * subscribers, multiple subscribers or multiple emissions of the same value.\r\n *\r\n * @example\r\n * const state$ = state.pipe(select());\r\n * state$.subscribe(state => doStuff(state));\r\n *\r\n * @returns Observable<T>\r\n */\r\n\r\nexport function select<T>(): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * @description\r\n * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n *\r\n * @example\r\n * const profilePicture$ = state.pipe(\r\n *   select(\r\n *    pluck('profilePicture'),\r\n *    switchMap(profilePicture => mapImageAsync(profilePicture))\r\n *   )\r\n * );\r\n * @param  { OperatorFunction<T, A> } op\r\n * @returns Observable<A>\r\n *\r\n * @docsPage select\r\n * @docsCategory operators\r\n */\r\nexport function select<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n\r\n/**\r\n * @description\r\n * Access a single property of the state by providing keys.\r\n * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n *\r\n * @example\r\n *  // Access a single property\r\n * const bar$ = state$.pipe(select('bar'));\r\n *\r\n * // Access a nested property\r\n * const foo$ = state$.pipe(select('bar', 'foo'));\r\n *\r\n * @return Observable<T[K1]>\r\n */\r\nexport function select<T, K1 extends keyof T>(\r\n  k1: K1\r\n): OperatorFunction<T, T[K1]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  k1: K1,\r\n  k2: K2\r\n): OperatorFunction<T, T[K1][K2]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2]\r\n>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3]\r\n>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4]\r\n>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]\r\n>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5,\r\n  k6: K6\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function select<T>(\r\n  ...opOrMapFn: OperatorFunction<T, any>[] | string[]\r\n): OperatorFunction<T, any> {\r\n  return (state$: Observable<T>) => {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    } else {\r\n      throw new Error('wrong params passed to select');\r\n    }\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\n\r\n/**\r\n * @internal\r\n */\r\nconst defaultCompare = <T, K extends keyof T>(oldVal: any, newVal: any) =>\r\n  oldVal === newVal;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * If properties of the source change, which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n * // An example comparing the first letters of just the name property.\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n * // compare the first letters of the name property\r\n * const customComparison: KeyCompareMap<Person> = {\r\n *   name: (oldName, newName) => oldName.substring(0, 3) === newName.substring(0, 3)\r\n * };\r\n *\r\n * of<Person>(\r\n *   { age: 4, name: 'Foo1'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo2'},\r\n *   { age: 6, name: 'Foo3'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(customComparison),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n *\r\n * @see {@link KeyCompareMap}\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\r\n * If properties of the source change which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n *\r\n * of(\r\n *   { age: 4, name: 'Foo'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo'},\r\n *   { age: 6, name: 'Foo'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(['age', 'name']),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo' }\r\n * // { age: 6, name: 'Foo' }\r\n *\r\n * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n * interface Person {\r\n *     age: number;\r\n *     name: string;\r\n *  }\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * of(\r\n *     { age: 4, name: 'Foo1'},\r\n *     { age: 7, name: 'Bar'},\r\n *     { age: 5, name: 'Foo2'},\r\n *     { age: 6, name: 'Foo3'},\r\n *   ).pipe(\r\n *     distinctUntilSomeChanged(['age', 'name'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n * // { age: 6, name: 'Foo3' }\r\n *\r\n * @param {K[]} keys String key for object property lookup on each item.\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * previous item in the source. (applied to each specified key)\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T> {\r\n  let distinctCompare: CompareFn<T>;\r\n  if (Array.isArray(keysOrMap)) {\r\n    const keys = keysOrMap;\r\n    const innerCompare: CompareFn<T[K]> = compare ? compare : defaultCompare;\r\n    distinctCompare = (oldState, newState) =>\r\n      keys.some(key => !innerCompare(oldState[key], newState[key]));\r\n  } else {\r\n    const keyComparatorMap = keysOrMap;\r\n    const innerCompare = (a: T[K], b: T[K], customCompFn?: CompareFn<T[K]>) =>\r\n      customCompFn ? customCompFn(a, b) : defaultCompare(a, b);\r\n    distinctCompare = (oldState, newState) => {\r\n      return Object.keys(keyComparatorMap).some(\r\n        key =>\r\n          !innerCompare(\r\n            (oldState as any)[key],\r\n            (newState as any)[key],\r\n            (keyComparatorMap as any)[key]\r\n          )\r\n      );\r\n    };\r\n  }\r\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\r\n}\r\n","import { Observable, OperatorFunction } from 'rxjs';\r\nimport { filter, map } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits a distinct subset of the received object.\r\n * You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n *\r\n * // Select title and panelOpen.\r\n * // compare the first letters of the `title` property and use the default comparison for `panelOpen`\r\n * const customComparison: KeyCompareMap<MyState> = {\r\n *   title: (oldTitle, newTitle) => oldTitle.substring(0, 3) === newTitle.substring(0, 3),\r\n *   panelOpen: undefined\r\n * };\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: false}\r\n * );\r\n * const viewModel$ = state$.pipe(\r\n *  selectSlice(customComparison),\r\n *  tap(console.log)\r\n * ).subscribe();\r\n *\r\n * // displays:\r\n * // { panelOpen: true, title: 'myTitle' }\r\n * // { panelOpen: true, title: 'newTitle' }\r\n * // { panelOpen: false, title: 'newTitle' }\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap* @docsPage selectSlice\r\n * @docsCategory operators\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\r\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\r\n * Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value\r\n *  should be emitted.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n * const state$: Observable<MyState> = of({\r\n *   title: 'myTitle',\r\n *   items: ['foo', 'bar'],\r\n *   panelOpen: true\r\n * });\r\n * const slice$ = state$.pipe(selectSlice(['items', 'panelOpen'])).pipe(tap(console.log)).subscribe();\r\n *\r\n * // displays:\r\n * // { items: ['foo', 'bar'], panelOpen: true }\r\n *\r\n * * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { selectSlices } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true}\r\n * )\r\n * .pipe(\r\n *     selectSlices(['title', 'items'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * //  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n * //  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n * //  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *\r\n * @param {(K)[]} keys - the array of keys which should be selected\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, R>;\r\n/**\r\n * @internal\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, Partial<T>> {\r\n  const keys = Array.isArray(keysOrMap)\r\n    ? keysOrMap\r\n    : (Object.keys(keysOrMap) as K[]);\r\n  const distinctOperator = Array.isArray(keysOrMap)\r\n    ? distinctUntilSomeChanged(keysOrMap, compare)\r\n    : distinctUntilSomeChanged(keysOrMap);\r\n\r\n  return (o$: Observable<T>): Observable<Partial<T>> =>\r\n    o$.pipe(\r\n      // to avoid emissions of empty objects map to present values and filter out emissions with no values present\r\n      map(state => ({\r\n        definedKeys: keys.filter(\r\n          k => state.hasOwnProperty(k) && state[k] !== undefined\r\n        ),\r\n        state\r\n      })),\r\n      filter(({ definedKeys, state }) => !!definedKeys.length),\r\n      // create view-model\r\n      map(({ definedKeys, state }) =>\r\n        definedKeys\r\n          .filter(k => state.hasOwnProperty(k) && state[k] !== undefined)\r\n          .reduce((vm, key) => {\r\n            vm[key] = state[key];\r\n            return vm;\r\n          }, {} as Partial<T>)\r\n      ),\r\n      // forward distinct values\r\n      distinctOperator\r\n    );\r\n}\r\n","import {\r\n  BehaviorSubject,\r\n  ConnectableObservable,\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport {\r\n  distinctUntilChanged,\r\n  mergeAll,\r\n  observeOn,\r\n  publish,\r\n  publishReplay,\r\n  scan,\r\n  tap,\r\n  withLatestFrom\r\n} from 'rxjs/operators';\r\n\r\nexport type AccumulationFn = <T>(st: T, sl: Partial<T>) => T;\r\n\r\nconst defaultAccumulator: AccumulationFn = <T>(st: T, sl: Partial<T>): T => {\r\n  return { ...st, ...sl };\r\n};\r\n\r\ninterface Accumulator<T> extends Subscribable<T> {\r\n  state: T;\r\n  state$: Observable<T>;\r\n  signal$: Observable<T>;\r\n  nextSlice: (stateSlice: Partial<T>) => void;\r\n  nextSliceObservable: (state$: Observable<Partial<T>>) => void;\r\n  nextAccumulator: (fn: AccumulationFn) => void;\r\n}\r\n\r\nexport function createAccumulationObservable<T extends object>(\r\n  stateObservables = new Subject<Observable<Partial<T>>>(),\r\n  stateSlices = new Subject<Partial<T>>(),\r\n  accumulatorObservable = new BehaviorSubject(defaultAccumulator)\r\n): Accumulator<T> {\r\n  const signal$ = merge(\r\n    stateObservables.pipe(\r\n      distinctUntilChanged(),\r\n      mergeAll(),\r\n      observeOn(queueScheduler)\r\n    ),\r\n    stateSlices.pipe(observeOn(queueScheduler))\r\n  ).pipe(\r\n    withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))),\r\n    scan(\r\n      (state, [slice, stateAccumulator]) => stateAccumulator(state, slice),\r\n      {} as T\r\n    ),\r\n    tap(newState => (compositionObservable.state = newState)),\r\n    publish()\r\n  );\r\n  const state$: Observable<T> = signal$.pipe(publishReplay(1));\r\n  const compositionObservable: Accumulator<T> = {\r\n    state: {} as T,\r\n    signal$,\r\n    state$,\r\n    nextSlice,\r\n    nextSliceObservable,\r\n    nextAccumulator,\r\n    subscribe\r\n  };\r\n\r\n  // ======\r\n\r\n  return compositionObservable;\r\n\r\n  // ======\r\n\r\n  function nextAccumulator(accumulatorFn: AccumulationFn): void {\r\n    accumulatorObservable.next(accumulatorFn);\r\n  }\r\n\r\n  function nextSlice(stateSlice: Partial<T>): void {\r\n    stateSlices.next(stateSlice);\r\n  }\r\n\r\n  function nextSliceObservable(stateObservable: Observable<Partial<T>>): void {\r\n    stateObservables.next(stateObservable);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    const sub = (compositionObservable.signal$ as ConnectableObservable<\r\n      T\r\n    >).connect();\r\n    sub.add(\r\n      (compositionObservable.state$ as ConnectableObservable<T>).connect()\r\n    );\r\n    return sub;\r\n  }\r\n}\r\n","import {\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport { mergeAll, observeOn } from 'rxjs/operators';\r\n\r\nexport function createSideEffectObservable<T>(\r\n  stateObservables = new Subject<Observable<T>>()\r\n): {\r\n  effects$: Observable<T>;\r\n  nextEffectObservable: (effect$: Observable<T>) => void;\r\n} & Subscribable<T> {\r\n  const effects$: Observable<T> = merge(\r\n    stateObservables.pipe(mergeAll(), observeOn(queueScheduler))\r\n  );\r\n\r\n  function nextEffectObservable(effect$: Observable<T>): void {\r\n    stateObservables.next(effect$);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    return effects$.subscribe();\r\n  }\r\n\r\n  return {\r\n    effects$,\r\n    nextEffectObservable,\r\n    subscribe\r\n  };\r\n}\r\n","import { Injectable, OnDestroy } from '@angular/core';\r\nimport {\r\n  isObservable,\r\n  Observable,\r\n  OperatorFunction,\r\n  Subscribable,\r\n  Subscription,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport {\r\n  createAccumulationObservable,\r\n  createSideEffectObservable,\r\n  isOperateFnArrayGuard,\r\n  isStringArrayGuard,\r\n  pipeFromArray,\r\n  stateful,\r\n  isKeyOf,\r\n  AccumulationFn\r\n} from './core';\r\nimport { filter, map, pluck, tap } from 'rxjs/operators';\r\n\r\ntype ProjectStateFn<T> = (oldState: T) => Partial<T>;\r\ntype ProjectValueFn<T, K extends keyof T> = (oldState: T) => T[K];\r\n\r\ntype ProjectStateReducer<T, V> = (oldState: T, value: V) => Partial<T>;\r\n\r\ntype ProjectValueReducer<T, K extends keyof T, V> = (\r\n  oldState: T,\r\n  value: V\r\n) => T[K];\r\n\r\n/**\r\n * @description\r\n * RxState is a light-weight reactive state management service for managing local state in angular.\r\n *\r\n * ![state logo](https://raw.githubusercontent.com/BioPhoton/rx-angular/master/libs/state/images/state_logo.png)\r\n *\r\n * @example\r\n * Component({\r\n *   selector: 'app-stateful',\r\n *   template: `<div>{{ state$ | async | json }}</div>`,\r\n *   providers: [RxState]\r\n * })\r\n * export class StatefulComponent {\r\n *   readonly state$ = this.state.select();\r\n *\r\n *   constructor(private state: RxState<{ foo: string }>) {}\r\n * }\r\n *\r\n * @docsCategory RxState\r\n * @docsPage RxState\r\n */\r\n@Injectable()\r\nexport class RxState<T extends object> implements OnDestroy, Subscribable<T> {\r\n  private subscription = new Subscription();\r\n\r\n  private accumulator = createAccumulationObservable<T>();\r\n  private effectObservable = createSideEffectObservable();\r\n\r\n  /**\r\n   * @description\r\n   * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.\r\n   * Use the `$` property if you want to read the state without having applied {@link stateful} to it.\r\n   */\r\n  readonly $: Observable<T> = this.accumulator.signal$;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor() {\r\n    this.subscription.add(this.subscribe());\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  ngOnDestroy(): void {\r\n    this.subscription.unsubscribe();\r\n  }\r\n\r\n  setAccumulator(accumulatorFn: AccumulationFn) {\r\n    this.accumulator.nextAccumulator(accumulatorFn);\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Read from the state in imperative manner. Returns the state object in its current state.\r\n   *\r\n   * @example\r\n   * const { disabled } = state.get();\r\n   * if (!disabled) {\r\n   *   doStuff();\r\n   * }\r\n   *\r\n   * @return T\r\n   */\r\n  get(): T {\r\n    return this.accumulator.state;\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate one or many properties of the state by providing a `Partial<T>` state or a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * // Update one or many properties of the state by providing a `Partial<T>`\r\n   *\r\n   * const partialState = {\r\n   *   foo: 'bar',\r\n   *   bar: 5\r\n   * };\r\n   * state.set(partialState);\r\n   *\r\n   * // Update one or many properties of the state by providing a `ProjectionFunction<T>`\r\n   *\r\n   * const reduceFn = oldState => ({\r\n   *   bar: oldState.bar + 5\r\n   * });\r\n   * state.set(reduceFn);\r\n   *\r\n   * @param {Partial<T>|ProjectStateFn<T>} stateOrProjectState\r\n   * @return void\r\n   */\r\n  set(stateOrProjectState: Partial<T> | ProjectStateFn<T>): void;\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate a single property of the state by the property name and a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * const reduceFn = oldState => oldState.bar + 5;\r\n   * state.set('bar', reduceFn);\r\n   *\r\n   * @param {K} key\r\n   * @param {ProjectValueFn<T, K>} projectSlice\r\n   * @return void\r\n   */\r\n  set<K extends keyof T, O>(key: K, projectSlice: ProjectValueFn<T, K>): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  set<K extends keyof T>(\r\n    keyOrStateOrProjectState: Partial<T> | ProjectStateFn<T> | K,\r\n    stateOrSliceProjectFn?: ProjectValueFn<T, K>\r\n  ): void {\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'object' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(keyOrStateOrProjectState);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'function' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(\r\n        keyOrStateOrProjectState(this.accumulator.state)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrStateOrProjectState) &&\r\n      typeof stateOrSliceProjectFn === 'function'\r\n    ) {\r\n      const state: Partial<T> = {};\r\n      state[keyOrStateOrProjectState] = stateOrSliceProjectFn(\r\n        this.accumulator.state\r\n      );\r\n      this.accumulator.nextSlice(state);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to set');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Connect an `Observable<Partial<T>>` to the state `T`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\r\n   *\r\n   * // Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\r\n   *\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\r\n   * // 5 due to the projectionFunction\r\n   */\r\n  connect<V>(\r\n    inputOrSlice$: Observable<Partial<T> | V>,\r\n    projectFn?: ProjectStateReducer<T, V>\r\n  ): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<T[K]>` source to a specific property `K` in the state `T`. Any emitted change will update\r\n   * this\r\n   * specific property in the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T>(key: K, slice$: Observable<T[K]>): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<V>` source to a specific property in the state. Additionally you can provide a\r\n   * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$, (state, timerChange) => state.timer += timerChange);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    key: K,\r\n    input$: Observable<V>,\r\n    projectSliceFn: ProjectValueReducer<T, K, V>\r\n  ): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    keyOrInputOrSlice$: K | Observable<Partial<T> | V>,\r\n    projectOrSlices$?: ProjectStateReducer<T, V> | Observable<T[K]>,\r\n    projectValueFn?: ProjectValueReducer<T, K, V>\r\n  ): void {\r\n    if (\r\n      isObservable<Partial<T>>(keyOrInputOrSlice$) &&\r\n      projectOrSlices$ === undefined &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined)\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isObservable<V>(keyOrInputOrSlice$) &&\r\n      typeof projectOrSlices$ === 'function' &&\r\n      !isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const project = projectOrSlices$;\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(v => project(this.get(), v))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: value }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<V>(projectOrSlices$) &&\r\n      typeof projectValueFn === 'function'\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: projectValueFn(this.get(), value) }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to connect');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<T>`. This way you don't have to think about **late\r\n   * subscribers**,\r\n   * **multiple subscribers** or **multiple emissions** of the same value\r\n   *\r\n   * @example\r\n   * const state$ = state.select();\r\n   * state$.subscribe(state => doStuff(state));\r\n   *\r\n   * @returns Observable<T>\r\n   */\r\n  select(): Observable<T>;\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n   * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n   *\r\n   * @example\r\n   * const profilePicture$ = state.select(\r\n   *  pluck('profilePicture'),\r\n   *  switchMap(profilePicture => mapImageAsync(profilePicture))\r\n   * );\r\n   * @param op { OperatorFunction<T, A> }\r\n   * @returns Observable<A>\r\n   */\r\n  select<A = T>(op: OperatorFunction<T, A>): Observable<A>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>\r\n  ): Observable<B>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>\r\n  ): Observable<C>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>\r\n  ): Observable<D>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C, E = D>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>\r\n  ): Observable<E>;\r\n  /**\r\n   * @description\r\n   * Access a single property of the state by providing keys.\r\n   * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n   *\r\n   * @example\r\n   * // Access a single property\r\n   *\r\n   * const bar$ = state.select('bar');\r\n   *\r\n   * // Access a nested property\r\n   *\r\n   * const foo$ = state.select('bar', 'foo');\r\n   *\r\n   * @return Observable<T[K1]>\r\n   */\r\n  select<K1 extends keyof T>(k1: K1): Observable<T[K1]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T, K2 extends keyof T[K1]>(\r\n    k1: K1,\r\n    k2: K2\r\n  ): Observable<T[K1][K2]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2]\r\n  >(k1: K1, k2: K2, k3: K3): Observable<T[K1][K2][K3]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4): Observable<T[K1][K2][K3][K4]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): Observable<T[K1][K2][K3][K4][K5]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4],\r\n    K6 extends keyof T[K1][K2][K3][K4][K5]\r\n  >(\r\n    k1: K1,\r\n    k2: K2,\r\n    k3: K3,\r\n    k4: K4,\r\n    k5: K5,\r\n    k6: K6\r\n  ): Observable<T[K1][K2][K3][K4][K5][K6]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<R>(\r\n    ...opOrMapFn: OperatorFunction<T, R>[] | string[]\r\n  ): Observable<T | R> {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return this.accumulator.state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    }\r\n    throw new Error('wrong params passed to select');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional\r\n   * `sideEffectFunction`.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * // Directly pass an observable side-effect\r\n   * const localStorageEffect$ = changes$.pipe(\r\n   *  tap(changes => storeChanges(changes))\r\n   * );\r\n   * state.hold(localStorageEffect$);\r\n   *\r\n   * // Pass an additional `sideEffectFunction`\r\n   *\r\n   * const localStorageEffectFn = changes => storeChanges(changes);\r\n   * state.hold(changes$, localStorageEffectFn);\r\n   *\r\n   * @param {Observable<S>} obsOrObsWithSideEffect\r\n   * @param {function} [sideEffectFn]\r\n   */\r\n  hold<S>(\r\n    obsOrObsWithSideEffect: Observable<S>,\r\n    sideEffectFn?: (arg: S) => void\r\n  ): void {\r\n    if (typeof sideEffectFn === 'function') {\r\n      this.effectObservable.nextEffectObservable(\r\n        obsOrObsWithSideEffect.pipe(tap(sideEffectFn))\r\n      );\r\n      return;\r\n    }\r\n    this.effectObservable.nextEffectObservable(obsOrObsWithSideEffect);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  subscribe(): Unsubscribable {\r\n    const subscription = new Subscription();\r\n    subscription.add(this.accumulator.subscribe());\r\n    subscription.add(this.effectObservable.subscribe());\r\n    return subscription;\r\n  }\r\n}\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"]}