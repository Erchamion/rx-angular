{"version":3,"file":"accumulation-observable.js","sourceRoot":"ng://@rx-angular/state/","sources":["lib/core/accumulation-observable.ts"],"names":[],"mappings":";AAAA,OAAO,EACL,eAAe,EAEf,KAAK,EAEL,cAAc,EACd,OAAO,EAGR,MAAM,MAAM,CAAC;AACd,OAAO,EACL,oBAAoB,EACpB,QAAQ,EACR,SAAS,EACT,OAAO,EACP,aAAa,EACb,IAAI,EACJ,GAAG,EACH,cAAc,EACf,MAAM,gBAAgB,CAAC;AAIxB,IAAM,kBAAkB,GAAmB,UAAI,EAAK,EAAE,EAAc;IAClE,6BAAY,EAAE,GAAK,EAAE,EAAG;AAC1B,CAAC,CAAC;;AAWF,MAAM,UAAU,4BAA4B,CAC1C,gBAAwD,EACxD,WAAuC,EACvC,qBAA+D;IAF/D,iCAAA,EAAA,uBAAuB,OAAO,EAA0B;IACxD,4BAAA,EAAA,kBAAkB,OAAO,EAAc;IACvC,sCAAA,EAAA,4BAA4B,eAAe,CAAC,kBAAkB,CAAC;IAE/D,IAAM,OAAO,GAAG,KAAK,CACnB,gBAAgB,CAAC,IAAI,CACnB,oBAAoB,EAAE,EACtB,QAAQ,EAAE,EACV,SAAS,CAAC,cAAc,CAAC,CAC1B,EACD,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,CAC5C,CAAC,IAAI,CACJ,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,CAAC,EACrE,IAAI,CACF,UAAC,KAAK,EAAE,EAAyB;YAAzB,kBAAyB,EAAxB,aAAK,EAAE,wBAAgB;QAAM,OAAA,gBAAgB,CAAC,KAAK,EAAE,KAAK,CAAC;IAA9B,CAA8B,EACpE,EAAO,CACR,EACD,GAAG,CAAC,UAAA,QAAQ,IAAI,OAAA,CAAC,qBAAqB,CAAC,KAAK,GAAG,QAAQ,CAAC,EAAxC,CAAwC,CAAC,EACzD,OAAO,EAAE,CACV,CAAC;IACF,IAAM,MAAM,GAAkB,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7D,IAAM,qBAAqB,GAAmB;QAC5C,KAAK,EAAE,EAAO;QACd,OAAO,SAAA;QACP,MAAM,QAAA;QACN,SAAS,WAAA;QACT,mBAAmB,qBAAA;QACnB,eAAe,iBAAA;QACf,SAAS,WAAA;KACV,CAAC;IAEF,SAAS;IAET,OAAO,qBAAqB,CAAC;IAE7B,SAAS;IAET,SAAS,eAAe,CAAC,aAA6B;QACpD,qBAAqB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAC5C,CAAC;IAED,SAAS,SAAS,CAAC,UAAsB;QACvC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC/B,CAAC;IAED,SAAS,mBAAmB,CAAC,eAAuC;QAClE,gBAAgB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IACzC,CAAC;IAED,SAAS,SAAS;QAChB,IAAM,GAAG,GAAI,qBAAqB,CAAC,OAEjC,CAAC,OAAO,EAAE,CAAC;QACb,GAAG,CAAC,GAAG,CACJ,qBAAqB,CAAC,MAAmC,CAAC,OAAO,EAAE,CACrE,CAAC;QACF,OAAO,GAAG,CAAC;IACb,CAAC;AACH,CAAC","sourcesContent":["import {\r\n  BehaviorSubject,\r\n  ConnectableObservable,\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport {\r\n  distinctUntilChanged,\r\n  mergeAll,\r\n  observeOn,\r\n  publish,\r\n  publishReplay,\r\n  scan,\r\n  tap,\r\n  withLatestFrom\r\n} from 'rxjs/operators';\r\n\r\nexport type AccumulationFn = <T>(st: T, sl: Partial<T>) => T;\r\n\r\nconst defaultAccumulator: AccumulationFn = <T>(st: T, sl: Partial<T>): T => {\r\n  return { ...st, ...sl };\r\n};\r\n\r\ninterface Accumulator<T> extends Subscribable<T> {\r\n  state: T;\r\n  state$: Observable<T>;\r\n  signal$: Observable<T>;\r\n  nextSlice: (stateSlice: Partial<T>) => void;\r\n  nextSliceObservable: (state$: Observable<Partial<T>>) => void;\r\n  nextAccumulator: (fn: AccumulationFn) => void;\r\n}\r\n\r\nexport function createAccumulationObservable<T extends object>(\r\n  stateObservables = new Subject<Observable<Partial<T>>>(),\r\n  stateSlices = new Subject<Partial<T>>(),\r\n  accumulatorObservable = new BehaviorSubject(defaultAccumulator)\r\n): Accumulator<T> {\r\n  const signal$ = merge(\r\n    stateObservables.pipe(\r\n      distinctUntilChanged(),\r\n      mergeAll(),\r\n      observeOn(queueScheduler)\r\n    ),\r\n    stateSlices.pipe(observeOn(queueScheduler))\r\n  ).pipe(\r\n    withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))),\r\n    scan(\r\n      (state, [slice, stateAccumulator]) => stateAccumulator(state, slice),\r\n      {} as T\r\n    ),\r\n    tap(newState => (compositionObservable.state = newState)),\r\n    publish()\r\n  );\r\n  const state$: Observable<T> = signal$.pipe(publishReplay(1));\r\n  const compositionObservable: Accumulator<T> = {\r\n    state: {} as T,\r\n    signal$,\r\n    state$,\r\n    nextSlice,\r\n    nextSliceObservable,\r\n    nextAccumulator,\r\n    subscribe\r\n  };\r\n\r\n  // ======\r\n\r\n  return compositionObservable;\r\n\r\n  // ======\r\n\r\n  function nextAccumulator(accumulatorFn: AccumulationFn): void {\r\n    accumulatorObservable.next(accumulatorFn);\r\n  }\r\n\r\n  function nextSlice(stateSlice: Partial<T>): void {\r\n    stateSlices.next(stateSlice);\r\n  }\r\n\r\n  function nextSliceObservable(stateObservable: Observable<Partial<T>>): void {\r\n    stateObservables.next(stateObservable);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    const sub = (compositionObservable.signal$ as ConnectableObservable<\r\n      T\r\n    >).connect();\r\n    sub.add(\r\n      (compositionObservable.state$ as ConnectableObservable<T>).connect()\r\n    );\r\n    return sub;\r\n  }\r\n}\r\n"]}