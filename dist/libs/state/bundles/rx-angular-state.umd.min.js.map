{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@rx-angular/state/lib/core/utils/pipe-from-array.ts","ng://@rx-angular/state/lib/core/utils/typing.ts","ng://@rx-angular/state/lib/rxjs/operators/stateful.ts","ng://@rx-angular/state/lib/rxjs/operators/distinctUntilSomeChanged.ts","ng://@rx-angular/state/lib/core/accumulation-observable.ts","ng://@rx-angular/state/lib/rx-state.service.ts","ng://@rx-angular/state/lib/core/side-effect-observable.ts","ng://@rx-angular/state/lib/rxjs/operators/select.ts","ng://@rx-angular/state/lib/rxjs/operators/selectSlice.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__metadata","metadataKey","metadataValue","Reflect","metadata","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","__spread","concat","pipeFromArray","fns","input","reduce","prev","fn","noop","isOperateFnArrayGuard","op","Array","isArray","every","isStringArrayGuard","isKeyOf","k","stateful","optionalDerive","_i","pipe","distinctUntilChanged","filter","v","undefined","shareReplay","bufferSize","refCount","defaultCompare","oldVal","newVal","distinctUntilSomeChanged","keysOrMap","compare","distinctCompare","keys_1","innerCompare_1","oldState","newState","some","key","keyComparatorMap_1","keys","a","b","customCompFn","oldV","newV","defaultAccumulator","st","sl","RxState","subscription","Subscription","accumulator","stateObservables","stateSlices","accumulatorObservable","Subject","BehaviorSubject","signal$","merge","mergeAll","observeOn","queueScheduler","withLatestFrom","scan","state","_a","_b","slice","stateAccumulator","tap","compositionObservable","publish","state$","publishReplay","nextSlice","stateSlice","nextSliceObservable","stateObservable","nextAccumulator","accumulatorFn","subscribe","sub","connect","add","createAccumulationObservable","effectObservable","effects$","nextEffectObservable","effect$","createSideEffectObservable","$","ngOnDestroy","unsubscribe","setAccumulator","get","set","keyOrStateOrProjectState","stateOrSliceProjectFn","Error","keyOrInputOrSlice$","projectOrSlices$","projectValueFn","_this","isObservable","slice$","key_1","map","key_2","project_1","select","opOrMapFn","pluck","hold","obsOrObsWithSideEffect","sideEffectFn","decorators","target","desc","d","c","getOwnPropertyDescriptor","decorate","defineProperty","__decorate","Injectable","distinctOperator","o$","definedKeys","vm"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { noop, UnaryFunction } from 'rxjs';\r\n\r\nexport function pipeFromArray<T, R>(\r\n  fns: Array<UnaryFunction<T, R>>\r\n): UnaryFunction<T, R> {\r\n  if (!fns) {\r\n    return noop as UnaryFunction<any, any>;\r\n  }\r\n\r\n  if (fns.length === 1) {\r\n    return fns[0];\r\n  }\r\n\r\n  return function piped(input: T): R {\r\n    return fns.reduce(\r\n      (prev: any, fn: UnaryFunction<T, R>) => fn(prev),\r\n      input as any\r\n    );\r\n  };\r\n}\r\n","import { OperatorFunction } from 'rxjs';\r\n\r\nexport function isPromiseGuard<T>(value: unknown): value is Promise<T> {\r\n  return (\r\n    !!value &&\r\n    typeof (<any>value).subscribe !== 'function' &&\r\n    typeof (value as any).then === 'function'\r\n  );\r\n}\r\n\r\nexport function isOperateFnArrayGuard<T, R = T>(\r\n  op: any[]\r\n): op is OperatorFunction<T, R>[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'function');\r\n}\r\n\r\nexport function isStringArrayGuard(op: any[]): op is string[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'string');\r\n}\r\n\r\nexport function isIterableGuard<T>(obj: unknown): obj is Array<T> {\r\n  if (obj === null || obj === undefined) {\r\n    return false;\r\n  }\r\n  return typeof (obj as any)[Symbol.iterator] === 'function';\r\n}\r\n\r\nexport function isKeyOf<O>(k: unknown): k is keyof O {\r\n  return (\r\n    !!k &&\r\n    (typeof k === 'string' || typeof k === 'symbol' || typeof k === 'number')\r\n  );\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged, filter, shareReplay } from 'rxjs/operators';\r\nimport { isOperateFnArrayGuard, pipeFromArray } from '../../core/utils';\r\n\r\n/**\r\n * @description\r\n *\r\n * As the name `stateful` implies this operator is useful when you process an Observable which maintains state.\r\n *\r\n * Maintaining state as an `Observable` source comes with a handful of repetitive as well as use case specific tasks.\r\n *\r\n * It acts like the Observables `pipe` method.\r\n * It accepts RxJS operators and composes them like `Observable#pipe` and the standalone `pipe` method.\r\n *\r\n * Furthermore, it takes care of the above mentioned repetitive tasks as listed below.\r\n *\r\n * You will always (aka repetitive) want to ensure that:\r\n * - only distinct state changes are emitted\r\n * - only defined values are emitted (filter out undefined, which ensures lazy state)\r\n * - share and replay custom operations for multiple subscribers (saves performance)\r\n *\r\n * You will sometimes (aka situational) need:\r\n * - a subset of the state (derivations)\r\n * - compose the state with other Observables or change the Observables behaviour\r\n *\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n * @return OperatorFunction<T, A>\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T>(): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n/**\r\n * @description\r\n *\r\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T, R>(\r\n  ...optionalDerive: OperatorFunction<T, R>[]\r\n): OperatorFunction<T, T | R> {\r\n  return (s: Observable<T>): Observable<T | R> => {\r\n    return s.pipe(\r\n      // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\r\n      // of data) @TODO evaluate benefits vs. overhead\r\n      distinctUntilChanged(),\r\n      // CUSTOM LOGIC HERE\r\n      (o: Observable<T>): Observable<T | R> => {\r\n        if (isOperateFnArrayGuard(optionalDerive)) {\r\n          return o.pipe(pipeFromArray(optionalDerive));\r\n        }\r\n        return o;\r\n      },\r\n      // initial emissions, undefined is no base-state, pollution with skip(1)\r\n      filter(v => v !== undefined),\r\n      // distinct same derivation value\r\n      distinctUntilChanged(),\r\n      // reuse custom operations result for multiple subscribers and reemit the last calculated value.\r\n      shareReplay({ bufferSize: 1, refCount: true })\r\n    );\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\n\r\n/**\r\n * @internal\r\n */\r\nconst defaultCompare = <T, K extends keyof T>(oldVal: any, newVal: any) =>\r\n  oldVal === newVal;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * If properties of the source change, which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n * // An example comparing the first letters of just the name property.\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n * // compare the first letters of the name property\r\n * const customComparison: KeyCompareMap<Person> = {\r\n *   name: (oldName, newName) => oldName.substring(0, 3) === newName.substring(0, 3)\r\n * };\r\n *\r\n * of<Person>(\r\n *   { age: 4, name: 'Foo1'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo2'},\r\n *   { age: 6, name: 'Foo3'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(customComparison),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n *\r\n * @see {@link KeyCompareMap}\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\r\n * If properties of the source change which are not specified for comparison, no change will be emitted.\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n *\r\n * of(\r\n *   { age: 4, name: 'Foo'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo'},\r\n *   { age: 6, name: 'Foo'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(['age', 'name']),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo' }\r\n * // { age: 6, name: 'Foo' }\r\n *\r\n * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n * interface Person {\r\n *     age: number;\r\n *     name: string;\r\n *  }\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * of(\r\n *     { age: 4, name: 'Foo1'},\r\n *     { age: 7, name: 'Bar'},\r\n *     { age: 5, name: 'Foo2'},\r\n *     { age: 6, name: 'Foo3'},\r\n *   ).pipe(\r\n *     distinctUntilSomeChanged(['age', 'name'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n * // { age: 6, name: 'Foo3' }\r\n *\r\n * @param {K[]} keys String key for object property lookup on each item.\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * previous item in the source. (applied to each specified key)\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): MonoTypeOperatorFunction<T> {\r\n  let distinctCompare: CompareFn<T>;\r\n  if (Array.isArray(keysOrMap)) {\r\n    const keys = keysOrMap;\r\n    const innerCompare: CompareFn<T[K]> = compare ? compare : defaultCompare;\r\n    distinctCompare = (oldState, newState) =>\r\n      keys.some(key => !innerCompare(oldState[key], newState[key]));\r\n  } else {\r\n    const keyComparatorMap = keysOrMap;\r\n    const innerCompare = (a: T[K], b: T[K], customCompFn?: CompareFn<T[K]>) =>\r\n      customCompFn ? customCompFn(a, b) : defaultCompare(a, b);\r\n    distinctCompare = (oldState, newState) => {\r\n      return Object.keys(keyComparatorMap).some(\r\n        key =>\r\n          !innerCompare(\r\n            (oldState as any)[key],\r\n            (newState as any)[key],\r\n            (keyComparatorMap as any)[key]\r\n          )\r\n      );\r\n    };\r\n  }\r\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\r\n}\r\n","import {\r\n  BehaviorSubject,\r\n  ConnectableObservable,\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport {\r\n  distinctUntilChanged,\r\n  mergeAll,\r\n  observeOn,\r\n  publish,\r\n  publishReplay,\r\n  scan,\r\n  tap,\r\n  withLatestFrom\r\n} from 'rxjs/operators';\r\n\r\nexport type AccumulationFn = <T>(st: T, sl: Partial<T>) => T;\r\n\r\nconst defaultAccumulator: AccumulationFn = <T>(st: T, sl: Partial<T>): T => {\r\n  return { ...st, ...sl };\r\n};\r\n\r\ninterface Accumulator<T> extends Subscribable<T> {\r\n  state: T;\r\n  state$: Observable<T>;\r\n  signal$: Observable<T>;\r\n  nextSlice: (stateSlice: Partial<T>) => void;\r\n  nextSliceObservable: (state$: Observable<Partial<T>>) => void;\r\n  nextAccumulator: (fn: AccumulationFn) => void;\r\n}\r\n\r\nexport function createAccumulationObservable<T extends object>(\r\n  stateObservables = new Subject<Observable<Partial<T>>>(),\r\n  stateSlices = new Subject<Partial<T>>(),\r\n  accumulatorObservable = new BehaviorSubject(defaultAccumulator)\r\n): Accumulator<T> {\r\n  const signal$ = merge(\r\n    stateObservables.pipe(\r\n      distinctUntilChanged(),\r\n      mergeAll(),\r\n      observeOn(queueScheduler)\r\n    ),\r\n    stateSlices.pipe(observeOn(queueScheduler))\r\n  ).pipe(\r\n    withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))),\r\n    scan(\r\n      (state, [slice, stateAccumulator]) => stateAccumulator(state, slice),\r\n      {} as T\r\n    ),\r\n    tap(newState => (compositionObservable.state = newState)),\r\n    publish()\r\n  );\r\n  const state$: Observable<T> = signal$.pipe(publishReplay(1));\r\n  const compositionObservable: Accumulator<T> = {\r\n    state: {} as T,\r\n    signal$,\r\n    state$,\r\n    nextSlice,\r\n    nextSliceObservable,\r\n    nextAccumulator,\r\n    subscribe\r\n  };\r\n\r\n  // ======\r\n\r\n  return compositionObservable;\r\n\r\n  // ======\r\n\r\n  function nextAccumulator(accumulatorFn: AccumulationFn): void {\r\n    accumulatorObservable.next(accumulatorFn);\r\n  }\r\n\r\n  function nextSlice(stateSlice: Partial<T>): void {\r\n    stateSlices.next(stateSlice);\r\n  }\r\n\r\n  function nextSliceObservable(stateObservable: Observable<Partial<T>>): void {\r\n    stateObservables.next(stateObservable);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    const sub = (compositionObservable.signal$ as ConnectableObservable<\r\n      T\r\n    >).connect();\r\n    sub.add(\r\n      (compositionObservable.state$ as ConnectableObservable<T>).connect()\r\n    );\r\n    return sub;\r\n  }\r\n}\r\n","import { Injectable, OnDestroy } from '@angular/core';\r\nimport {\r\n  isObservable,\r\n  Observable,\r\n  OperatorFunction,\r\n  Subscribable,\r\n  Subscription,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport {\r\n  createAccumulationObservable,\r\n  createSideEffectObservable,\r\n  isOperateFnArrayGuard,\r\n  isStringArrayGuard,\r\n  pipeFromArray,\r\n  stateful,\r\n  isKeyOf,\r\n  AccumulationFn\r\n} from './core';\r\nimport { filter, map, pluck, tap } from 'rxjs/operators';\r\n\r\ntype ProjectStateFn<T> = (oldState: T) => Partial<T>;\r\ntype ProjectValueFn<T, K extends keyof T> = (oldState: T) => T[K];\r\n\r\ntype ProjectStateReducer<T, V> = (oldState: T, value: V) => Partial<T>;\r\n\r\ntype ProjectValueReducer<T, K extends keyof T, V> = (\r\n  oldState: T,\r\n  value: V\r\n) => T[K];\r\n\r\n/**\r\n * @description\r\n * RxState is a light-weight reactive state management service for managing local state in angular.\r\n *\r\n * ![state logo](https://raw.githubusercontent.com/BioPhoton/rx-angular/master/libs/state/images/state_logo.png)\r\n *\r\n * @example\r\n * Component({\r\n *   selector: 'app-stateful',\r\n *   template: `<div>{{ state$ | async | json }}</div>`,\r\n *   providers: [RxState]\r\n * })\r\n * export class StatefulComponent {\r\n *   readonly state$ = this.state.select();\r\n *\r\n *   constructor(private state: RxState<{ foo: string }>) {}\r\n * }\r\n *\r\n * @docsCategory RxState\r\n * @docsPage RxState\r\n */\r\n@Injectable()\r\nexport class RxState<T extends object> implements OnDestroy, Subscribable<T> {\r\n  private subscription = new Subscription();\r\n\r\n  private accumulator = createAccumulationObservable<T>();\r\n  private effectObservable = createSideEffectObservable();\r\n\r\n  /**\r\n   * @description\r\n   * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.\r\n   * Use the `$` property if you want to read the state without having applied {@link stateful} to it.\r\n   */\r\n  readonly $: Observable<T> = this.accumulator.signal$;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor() {\r\n    this.subscription.add(this.subscribe());\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  ngOnDestroy(): void {\r\n    this.subscription.unsubscribe();\r\n  }\r\n\r\n  setAccumulator(accumulatorFn: AccumulationFn) {\r\n    this.accumulator.nextAccumulator(accumulatorFn);\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Read from the state in imperative manner. Returns the state object in its current state.\r\n   *\r\n   * @example\r\n   * const { disabled } = state.get();\r\n   * if (!disabled) {\r\n   *   doStuff();\r\n   * }\r\n   *\r\n   * @return T\r\n   */\r\n  get(): T {\r\n    return this.accumulator.state;\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate one or many properties of the state by providing a `Partial<T>` state or a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * // Update one or many properties of the state by providing a `Partial<T>`\r\n   *\r\n   * const partialState = {\r\n   *   foo: 'bar',\r\n   *   bar: 5\r\n   * };\r\n   * state.set(partialState);\r\n   *\r\n   * // Update one or many properties of the state by providing a `ProjectionFunction<T>`\r\n   *\r\n   * const reduceFn = oldState => ({\r\n   *   bar: oldState.bar + 5\r\n   * });\r\n   * state.set(reduceFn);\r\n   *\r\n   * @param {Partial<T>|ProjectStateFn<T>} stateOrProjectState\r\n   * @return void\r\n   */\r\n  set(stateOrProjectState: Partial<T> | ProjectStateFn<T>): void;\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate a single property of the state by the property name and a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * const reduceFn = oldState => oldState.bar + 5;\r\n   * state.set('bar', reduceFn);\r\n   *\r\n   * @param {K} key\r\n   * @param {ProjectValueFn<T, K>} projectSlice\r\n   * @return void\r\n   */\r\n  set<K extends keyof T, O>(key: K, projectSlice: ProjectValueFn<T, K>): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  set<K extends keyof T>(\r\n    keyOrStateOrProjectState: Partial<T> | ProjectStateFn<T> | K,\r\n    stateOrSliceProjectFn?: ProjectValueFn<T, K>\r\n  ): void {\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'object' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(keyOrStateOrProjectState);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'function' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(\r\n        keyOrStateOrProjectState(this.accumulator.state)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrStateOrProjectState) &&\r\n      typeof stateOrSliceProjectFn === 'function'\r\n    ) {\r\n      const state: Partial<T> = {};\r\n      state[keyOrStateOrProjectState] = stateOrSliceProjectFn(\r\n        this.accumulator.state\r\n      );\r\n      this.accumulator.nextSlice(state);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to set');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Connect an `Observable<Partial<T>>` to the state `T`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\r\n   *\r\n   * // Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\r\n   *\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\r\n   * // 5 due to the projectionFunction\r\n   */\r\n  connect<V>(\r\n    inputOrSlice$: Observable<Partial<T> | V>,\r\n    projectFn?: ProjectStateReducer<T, V>\r\n  ): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<T[K]>` source to a specific property `K` in the state `T`. Any emitted change will update\r\n   * this\r\n   * specific property in the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T>(key: K, slice$: Observable<T[K]>): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<V>` source to a specific property in the state. Additionally you can provide a\r\n   * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$, (state, timerChange) => state.timer += timerChange);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    key: K,\r\n    input$: Observable<V>,\r\n    projectSliceFn: ProjectValueReducer<T, K, V>\r\n  ): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    keyOrInputOrSlice$: K | Observable<Partial<T> | V>,\r\n    projectOrSlices$?: ProjectStateReducer<T, V> | Observable<T[K]>,\r\n    projectValueFn?: ProjectValueReducer<T, K, V>\r\n  ): void {\r\n    if (\r\n      isObservable<Partial<T>>(keyOrInputOrSlice$) &&\r\n      projectOrSlices$ === undefined &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined)\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isObservable<V>(keyOrInputOrSlice$) &&\r\n      typeof projectOrSlices$ === 'function' &&\r\n      !isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const project = projectOrSlices$;\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(v => project(this.get(), v))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<T[K]>(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: value }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable<V>(projectOrSlices$) &&\r\n      typeof projectValueFn === 'function'\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        filter(slice => slice !== undefined),\r\n        map(value => ({ ...{}, [key]: projectValueFn(this.get(), value) }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to connect');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<T>`. This way you don't have to think about **late\r\n   * subscribers**,\r\n   * **multiple subscribers** or **multiple emissions** of the same value\r\n   *\r\n   * @example\r\n   * const state$ = state.select();\r\n   * state$.subscribe(state => doStuff(state));\r\n   *\r\n   * @returns Observable<T>\r\n   */\r\n  select(): Observable<T>;\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n   * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n   *\r\n   * @example\r\n   * const profilePicture$ = state.select(\r\n   *  pluck('profilePicture'),\r\n   *  switchMap(profilePicture => mapImageAsync(profilePicture))\r\n   * );\r\n   * @param op { OperatorFunction<T, A> }\r\n   * @returns Observable<A>\r\n   */\r\n  select<A = T>(op: OperatorFunction<T, A>): Observable<A>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>\r\n  ): Observable<B>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>\r\n  ): Observable<C>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>\r\n  ): Observable<D>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C, E = D>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>\r\n  ): Observable<E>;\r\n  /**\r\n   * @description\r\n   * Access a single property of the state by providing keys.\r\n   * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n   *\r\n   * @example\r\n   * // Access a single property\r\n   *\r\n   * const bar$ = state.select('bar');\r\n   *\r\n   * // Access a nested property\r\n   *\r\n   * const foo$ = state.select('bar', 'foo');\r\n   *\r\n   * @return Observable<T[K1]>\r\n   */\r\n  select<K1 extends keyof T>(k1: K1): Observable<T[K1]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T, K2 extends keyof T[K1]>(\r\n    k1: K1,\r\n    k2: K2\r\n  ): Observable<T[K1][K2]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2]\r\n  >(k1: K1, k2: K2, k3: K3): Observable<T[K1][K2][K3]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4): Observable<T[K1][K2][K3][K4]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4]\r\n  >(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): Observable<T[K1][K2][K3][K4][K5]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<\r\n    K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4],\r\n    K6 extends keyof T[K1][K2][K3][K4][K5]\r\n  >(\r\n    k1: K1,\r\n    k2: K2,\r\n    k3: K3,\r\n    k4: K4,\r\n    k5: K5,\r\n    k6: K6\r\n  ): Observable<T[K1][K2][K3][K4][K5][K6]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<R>(\r\n    ...opOrMapFn: OperatorFunction<T, R>[] | string[]\r\n  ): Observable<T | R> {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return this.accumulator.state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    }\r\n    throw new Error('wrong params passed to select');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional\r\n   * `sideEffectFunction`.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * // Directly pass an observable side-effect\r\n   * const localStorageEffect$ = changes$.pipe(\r\n   *  tap(changes => storeChanges(changes))\r\n   * );\r\n   * state.hold(localStorageEffect$);\r\n   *\r\n   * // Pass an additional `sideEffectFunction`\r\n   *\r\n   * const localStorageEffectFn = changes => storeChanges(changes);\r\n   * state.hold(changes$, localStorageEffectFn);\r\n   *\r\n   * @param {Observable<S>} obsOrObsWithSideEffect\r\n   * @param {function} [sideEffectFn]\r\n   */\r\n  hold<S>(\r\n    obsOrObsWithSideEffect: Observable<S>,\r\n    sideEffectFn?: (arg: S) => void\r\n  ): void {\r\n    if (typeof sideEffectFn === 'function') {\r\n      this.effectObservable.nextEffectObservable(\r\n        obsOrObsWithSideEffect.pipe(tap(sideEffectFn))\r\n      );\r\n      return;\r\n    }\r\n    this.effectObservable.nextEffectObservable(obsOrObsWithSideEffect);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  subscribe(): Unsubscribable {\r\n    const subscription = new Subscription();\r\n    subscription.add(this.accumulator.subscribe());\r\n    subscription.add(this.effectObservable.subscribe());\r\n    return subscription;\r\n  }\r\n}\r\n","import {\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport { mergeAll, observeOn } from 'rxjs/operators';\r\n\r\nexport function createSideEffectObservable<T>(\r\n  stateObservables = new Subject<Observable<T>>()\r\n): {\r\n  effects$: Observable<T>;\r\n  nextEffectObservable: (effect$: Observable<T>) => void;\r\n} & Subscribable<T> {\r\n  const effects$: Observable<T> = merge(\r\n    stateObservables.pipe(mergeAll(), observeOn(queueScheduler))\r\n  );\r\n\r\n  function nextEffectObservable(effect$: Observable<T>): void {\r\n    stateObservables.next(effect$);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    return effects$.subscribe();\r\n  }\r\n\r\n  return {\r\n    effects$,\r\n    nextEffectObservable,\r\n    subscribe\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { pluck } from 'rxjs/operators';\r\nimport {\r\n  isOperateFnArrayGuard,\r\n  isStringArrayGuard,\r\n  pipeFromArray\r\n} from '../../core/utils';\r\nimport { stateful } from './stateful';\r\n\r\n/**\r\n * @description\r\n * returns the state as shared, replayed and distinct `Observable<T>`. This way you don't have to think about late\r\n * subscribers, multiple subscribers or multiple emissions of the same value.\r\n *\r\n * @example\r\n * const state$ = state.pipe(select());\r\n * state$.subscribe(state => doStuff(state));\r\n *\r\n * @returns Observable<T>\r\n */\r\n\r\nexport function select<T>(): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * @description\r\n * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n *\r\n * @example\r\n * const profilePicture$ = state.pipe(\r\n *   select(\r\n *    pluck('profilePicture'),\r\n *    switchMap(profilePicture => mapImageAsync(profilePicture))\r\n *   )\r\n * );\r\n * @param  { OperatorFunction<T, A> } op\r\n * @returns Observable<A>\r\n *\r\n * @docsPage select\r\n * @docsCategory operators\r\n */\r\nexport function select<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n\r\n/**\r\n * @description\r\n * Access a single property of the state by providing keys.\r\n * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n *\r\n * @example\r\n *  // Access a single property\r\n * const bar$ = state$.pipe(select('bar'));\r\n *\r\n * // Access a nested property\r\n * const foo$ = state$.pipe(select('bar', 'foo'));\r\n *\r\n * @return Observable<T[K1]>\r\n */\r\nexport function select<T, K1 extends keyof T>(\r\n  k1: K1\r\n): OperatorFunction<T, T[K1]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  k1: K1,\r\n  k2: K2\r\n): OperatorFunction<T, T[K1][K2]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2]\r\n>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3]\r\n>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4]\r\n>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]\r\n>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5,\r\n  k6: K6\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function select<T>(\r\n  ...opOrMapFn: OperatorFunction<T, any>[] | string[]\r\n): OperatorFunction<T, any> {\r\n  return (state$: Observable<T>) => {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    } else {\r\n      throw new Error('wrong params passed to select');\r\n    }\r\n  };\r\n}\r\n","import { Observable, OperatorFunction } from 'rxjs';\r\nimport { filter, map } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits a distinct subset of the received object.\r\n * You can provide a custom comparison for each key individually by setting a `KeyCompareMap<T>`.\r\n * If no comparison is provided for a specified key, an equality check is used by default.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n *\r\n * // Select title and panelOpen.\r\n * // compare the first letters of the `title` property and use the default comparison for `panelOpen`\r\n * const customComparison: KeyCompareMap<MyState> = {\r\n *   title: (oldTitle, newTitle) => oldTitle.substring(0, 3) === newTitle.substring(0, 3),\r\n *   panelOpen: undefined\r\n * };\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'bar'],  panelOpen: false}\r\n * );\r\n * const viewModel$ = state$.pipe(\r\n *  selectSlice(customComparison),\r\n *  tap(console.log)\r\n * ).subscribe();\r\n *\r\n * // displays:\r\n * // { panelOpen: true, title: 'myTitle' }\r\n * // { panelOpen: true, title: 'newTitle' }\r\n * // { panelOpen: false, title: 'newTitle' }\r\n *\r\n * @param {KeyCompareMap<T>} keyCompareMap* @docsPage selectSlice\r\n * @docsCategory operators\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keyCompareMap: KeyCompareMap<T>\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\r\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\r\n * Comparison will be done for each set key in the `keys` array.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value\r\n *  should be emitted.\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n * const state$: Observable<MyState> = of({\r\n *   title: 'myTitle',\r\n *   items: ['foo', 'bar'],\r\n *   panelOpen: true\r\n * });\r\n * const slice$ = state$.pipe(selectSlice(['items', 'panelOpen'])).pipe(tap(console.log)).subscribe();\r\n *\r\n * // displays:\r\n * // { items: ['foo', 'bar'], panelOpen: true }\r\n *\r\n * * @example\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { selectSlices } from 'rxjs/operators';\r\n * import { isDeepEqual } from 'custom/is-equal';\r\n *\r\n *\r\n *  const customCompare = (oldVal, newVal) => isDeepEqual(oldVal, newVal);\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n *  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true}\r\n * )\r\n * .pipe(\r\n *     selectSlices(['title', 'items'], customCompare),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * //  { title: 'myTitle', items: ['foo'],  panelOpen: true},\r\n * //  { title: 'myTitle2', items: ['foo', 'bar'],  panelOpen: true},\r\n * //  { title: 'newTitle', items: ['foo', 'baz'],  panelOpen: true},\r\n *\r\n * @param {(K)[]} keys - the array of keys which should be selected\r\n * @param {CompareFn<T[K]>} [compare] Optional comparison function called to test if an item is distinct from the\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keys: K[],\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, R>;\r\n/**\r\n * @internal\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T, R>(\r\n  keysOrMap: K[] | KeyCompareMap<T>,\r\n  compare?: CompareFn<T[K]>\r\n): OperatorFunction<T, Partial<T>> {\r\n  const keys = Array.isArray(keysOrMap)\r\n    ? keysOrMap\r\n    : (Object.keys(keysOrMap) as K[]);\r\n  const distinctOperator = Array.isArray(keysOrMap)\r\n    ? distinctUntilSomeChanged(keysOrMap, compare)\r\n    : distinctUntilSomeChanged(keysOrMap);\r\n\r\n  return (o$: Observable<T>): Observable<Partial<T>> =>\r\n    o$.pipe(\r\n      // to avoid emissions of empty objects map to present values and filter out emissions with no values present\r\n      map(state => ({\r\n        definedKeys: keys.filter(\r\n          k => state.hasOwnProperty(k) && state[k] !== undefined\r\n        ),\r\n        state\r\n      })),\r\n      filter(({ definedKeys, state }) => !!definedKeys.length),\r\n      // create view-model\r\n      map(({ definedKeys, state }) =>\r\n        definedKeys\r\n          .filter(k => state.hasOwnProperty(k) && state[k] !== undefined)\r\n          .reduce((vm, key) => {\r\n            vm[key] = state[key];\r\n            return vm;\r\n          }, {} as Partial<T>)\r\n      ),\r\n      // forward distinct values\r\n      distinctOperator\r\n    );\r\n}\r\n"]}