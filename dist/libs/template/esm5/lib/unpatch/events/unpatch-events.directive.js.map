{"version":3,"file":"unpatch-events.directive.js","sourceRoot":"ng://@rx-angular/template/","sources":["lib/unpatch/events/unpatch-events.directive.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,SAAS,EACT,UAAU,EACV,KAAK,EAEN,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,eAAe,EAAE,YAAY,EAAE,MAAM,MAAM,CAAC;AACrD,OAAO,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;AACrC,OAAO,EAAE,iBAAiB,EAAE,MAAM,sBAAsB,CAAC;AACzD,OAAO,EAAE,oBAAoB,EAAE,MAAM,iCAAiC,CAAC;;AAEvE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCG;AACH,8CAA8C;AAC9C;IAoBE,gCAAoB,EAAc;QAAd,OAAE,GAAF,EAAE,CAAY;QAlBlC,iBAAY,GAAG,IAAI,YAAY,EAAE,CAAC;QAClC,YAAO,GAAG,IAAI,eAAe,CAAW,iBAAiB,CAAC,CAAC;IAiBtB,CAAC;IAftC,sBACI,0CAAM;aADV,UACW,KAAe;YACxB,IAAI,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC7B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC1B;iBAAM;gBACL,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;aACtC;QACH,CAAC;;;OAAA;IAED,mEAAkC,GAAlC,UAAmC,MAAM;QAAzC,iBAIC;QAHC,MAAM,CAAC,OAAO,CAAC,UAAA,EAAE;YACf,oBAAoB,CAAC,KAAI,CAAC,EAAE,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC;IACL,CAAC;IAID,4CAAW,GAAX;QACE,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;IAClC,CAAC;IAED,gDAAe,GAAf;QAAA,iBAMC;QALC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO;aAC7B,IAAI,CACH,GAAG,CAAC,UAAA,SAAS,IAAI,OAAA,KAAI,CAAC,kCAAkC,CAAC,SAAS,CAAC,EAAlD,CAAkD,CAAC,CACrE;aACA,SAAS,EAAE,CAAC;IACjB,CAAC;gGA/BU,sBAAsB;+DAAtB,sBAAsB;iCArDnC;CAqFC,AAjCD,IAiCC;SAhCY,sBAAsB;kDAAtB,sBAAsB;cADlC,SAAS;eAAC,EAAE,QAAQ,EAAE,WAAW,EAAE;;kBAKjC,KAAK;mBAAC,SAAS","sourcesContent":["import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  Input,\r\n  OnDestroy\r\n} from '@angular/core';\r\nimport { BehaviorSubject, Subscription } from 'rxjs';\r\nimport { tap } from 'rxjs/operators';\r\nimport { zonePatchedEvents } from './unpatch-event-list';\r\nimport { unpatchEventListener } from '../../core/utils/make-zone-less';\r\n\r\n/**\r\n * @Directive UnpatchEventsDirective\r\n *\r\n * @description\r\n *\r\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\r\n * of unnecessary renderings through zones `addEventListener` patches.\r\n * It can be used on any element you apply event bindings.\r\n *\r\n * The current way of binding events to the DOM is to use output bindings:\r\n *  ```html\r\n * <button (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\r\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\r\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\r\n *\r\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\r\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\r\n *\r\n * `unpatch` directive solves that problem.\r\n *\r\n * Included Features:\r\n *  - by default un-patch all registered listeners of the host it is applied on\r\n *  - un-patch only a specified set of registered event listeners\r\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\r\n *  - Not interfering with any logic executed by the registered callback\r\n *\r\n * @usageNotes\r\n *\r\n * The `unpatch` directive can be used like shown here:\r\n * ```html\r\n * <button [unoatch] (click)=\"triggerSomeMethod($event)\">click me</button>\r\n * <button [unoatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n// tslint:disable-next-line:directive-selector\r\n@Directive({ selector: '[unpatch]' })\r\nexport class UnpatchEventsDirective implements AfterViewInit, OnDestroy {\r\n  subscription = new Subscription();\r\n  events$ = new BehaviorSubject<string[]>(zonePatchedEvents);\r\n\r\n  @Input('unpatch')\r\n  set events(value: string[]) {\r\n    if (value && value.length > 0) {\r\n      this.events$.next(value);\r\n    } else {\r\n      this.events$.next(zonePatchedEvents);\r\n    }\r\n  }\r\n\r\n  reapplyEventListenersZoneUnPatched(events) {\r\n    events.forEach(ev => {\r\n      unpatchEventListener(this.el.nativeElement, ev);\r\n    });\r\n  }\r\n\r\n  constructor(private el: ElementRef) {}\r\n\r\n  ngOnDestroy() {\r\n    this.subscription.unsubscribe();\r\n  }\r\n\r\n  ngAfterViewInit(): void {\r\n    this.subscription = this.events$\r\n      .pipe(\r\n        tap(eventList => this.reapplyEventListenersZoneUnPatched(eventList))\r\n      )\r\n      .subscribe();\r\n  }\r\n}\r\n"]}