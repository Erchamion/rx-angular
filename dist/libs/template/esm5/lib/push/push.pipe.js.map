{"version":3,"file":"push.pipe.js","sourceRoot":"ng://@rx-angular/template/","sources":["lib/push/push.pipe.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,iBAAiB,EAEjB,IAAI,EAEL,MAAM,eAAe,CAAC;AAOvB,OAAO,EAAe,iBAAiB,EAAE,MAAM,SAAS,CAAC;AACzD,OAAO,EAAE,aAAa,EAAE,MAAM,sBAAsB,CAAC;AACrD,OAAO,EAAE,qBAAqB,EAAE,MAAM,gDAAgD,CAAC;;AAEvF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA0CG;AACH;IAeE,kBAAY,KAAwB;QAApC,iBAOC;QAhBgB,kBAAa,GAAuB;YACnD,IAAI,EAAE;gBACJ,KAAI,CAAC,aAAa,GAAG,SAAS,CAAC;YACjC,CAAC;SACF,CAAC;QACe,mBAAc,GAAuC;YACpE,IAAI,EAAE,UAAC,KAA2B,IAAK,OAAA,CAAC,KAAI,CAAC,aAAa,GAAG,KAAK,CAAC,EAA5B,CAA4B;SACpE,CAAC;QAGA,IAAI,CAAC,WAAW,GAAG,iBAAiB,CAAI;YACtC,UAAU,EAAE,aAAa,CAAI,EAAE,KAAK,OAAA,EAAE,CAAC;YACvC,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,aAAa,EAAE,IAAI,CAAC,aAAa;SAClC,CAAC,CAAC;QACH,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;IACnD,CAAC;IAcD,4BAAS,GAAT,UACE,mBAA0D,EAC1D,MAA+C;QAE/C,IAAM,QAAQ,GAAG,MAAM,IAAI,qBAAqB,CAAC;QACjD,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACxC,IAAI,CAAC,WAAW,CAAC,uBAAuB,CAAC,mBAAmB,CAAC,CAAC;QAC9D,OAAO,IAAI,CAAC,aAAoB,CAAC;IACnC,CAAC;IAED,8BAAW,GAAX;QACE,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;IAClC,CAAC;oEA/CU,QAAQ;2DAAR,QAAQ;mBA5DrB;CA4GC,AAjDD,IAiDC;SAhDY,QAAQ;kDAAR,QAAQ;cADpB,IAAI;eAAC,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE","sourcesContent":["import {\r\n  ChangeDetectorRef,\r\n  OnDestroy,\r\n  Pipe,\r\n  PipeTransform\r\n} from '@angular/core';\r\nimport {\r\n  NextObserver,\r\n  Observable,\r\n  ObservableInput,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport { RenderAware, createRenderAware } from '../core';\r\nimport { getStrategies } from '../render-strategies';\r\nimport { DEFAULT_STRATEGY_NAME } from '../render-strategies/strategies/strategies-map';\r\n\r\n/**\r\n * @Pipe PushPipe\r\n *\r\n * @description\r\n *\r\n * The `push` pipe serves as a drop-in replacement for the `async` pipe.\r\n * It contains intelligent handling of change detection to enable us\r\n * running in zone-full as well as zone-less mode without any changes to the code.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n *  ```html\r\n *  {{observable$ | async}}\r\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | async\"></component>\r\n * ```\r\n *\r\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\r\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked\r\n *     components.\r\n *\r\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\r\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\r\n *\r\n * `push` pipe solves that problem.\r\n *\r\n * Included Features:\r\n *  - Take observables or promises, retrieve their values and render the value to the template\r\n *  - Handling null and undefined values in a clean unified/structured way\r\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\r\n *  - Distinct same values in a row to increase performance\r\n *  - Coalescing of change detection calls to boost performance\r\n *\r\n * @usageNotes\r\n *\r\n * `push` pipe solves that problem. It can be used like shown here:\r\n * ```html\r\n * {{observable$ | push}}\r\n * <ng-container *ngIf=\"observable$ | push as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | push\"></component>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n@Pipe({ name: 'push', pure: false })\r\nexport class PushPipe<S> implements PipeTransform, OnDestroy {\r\n  private renderedValue: S | null | undefined;\r\n\r\n  private readonly subscription: Unsubscribable;\r\n  private readonly RenderAware: RenderAware<S | null | undefined>;\r\n  private readonly resetObserver: NextObserver<void> = {\r\n    next: () => {\r\n      this.renderedValue = undefined;\r\n    }\r\n  };\r\n  private readonly updateObserver: NextObserver<S | null | undefined> = {\r\n    next: (value: S | null | undefined) => (this.renderedValue = value)\r\n  };\r\n\r\n  constructor(cdRef: ChangeDetectorRef) {\r\n    this.RenderAware = createRenderAware<S>({\r\n      strategies: getStrategies<S>({ cdRef }),\r\n      updateObserver: this.updateObserver,\r\n      resetObserver: this.resetObserver\r\n    });\r\n    this.subscription = this.RenderAware.subscribe();\r\n  }\r\n\r\n  transform<T>(\r\n    potentialObservable: null,\r\n    config?: string | Observable<string>\r\n  ): null;\r\n  transform<T>(\r\n    potentialObservable: undefined,\r\n    config?: string | Observable<string>\r\n  ): undefined;\r\n  transform<T>(\r\n    potentialObservable: ObservableInput<T>,\r\n    config?: string | Observable<string>\r\n  ): T;\r\n  transform<T>(\r\n    potentialObservable: ObservableInput<T> | null | undefined,\r\n    config: string | Observable<string> | undefined\r\n  ): T | null | undefined {\r\n    const strategy = config || DEFAULT_STRATEGY_NAME;\r\n    this.RenderAware.nextStrategy(strategy);\r\n    this.RenderAware.nextPotentialObservable(potentialObservable);\r\n    return this.renderedValue as any;\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.subscription.unsubscribe();\r\n  }\r\n}\r\n"]}