{"version":3,"file":"render-aware_creator.js","sourceRoot":"ng://@rx-angular/template/","sources":["lib/core/render-aware/render-aware_creator.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,KAAK,EAGL,EAAE,EACF,aAAa,EAGb,YAAY,EACb,MAAM,MAAM,CAAC;AACd,OAAO,EACL,UAAU,EACV,oBAAoB,EACpB,MAAM,EACN,GAAG,EAGH,SAAS,EACT,GAAG,EACH,cAAc,EACf,MAAM,gBAAgB,CAAC;AAExB,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AASlD;;;;;;;;GAQG;AACH,MAAM,UAAU,iBAAiB,CAAI,GAIpC;IACC,MAAM,aAAa,GAAG,IAAI,aAAa,CAA8B,CAAC,CAAC,CAAC;IACxE,MAAM,SAAS,GAAkC,aAAa,CAAC,IAAI,CACjE,oBAAoB,EAAE,EACtB,SAAS,CAAC,kBAAkB,CAAC,EAAE,CAC7B,OAAO,kBAAkB,KAAK,QAAQ;QACpC,CAAC,CAAC,EAAE,CAAC,kBAAkB,CAAC;QACxB,CAAC,CAAC,kBAAkB,CACvB,EACD,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,CAC/B,CAAC;IAEF,MAAM,wBAAwB,GAAG,IAAI,aAAa,CAAgB,CAAC,CAAC,CAAC;IACrE,MAAM,mBAAmB,GAAG,wBAAwB,CAAC,IAAI,CACvD,oBAAoB,EAAE,CACvB,CAAC;IACF,IAAI,6BAA6B,GAAG,IAAI,CAAC;IAEzC,MAAM,gBAAgB,GAAG,mBAAmB,CAAC,IAAI;IAC/C,8DAA8D;IAC9D,GAAG,CAAC,WAAW,CAAC,EAAE;QAChB,IAAI,WAAW,KAAK,IAAI,EAAE;YACxB,OAAO,EAAE,CAAC,IAAI,CAAC,CAAC;SACjB;QACD,IAAI,CAAC,6BAA6B,EAAE;YAClC,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;YACzB,IAAI,WAAW,KAAK,SAAS,EAAE;gBAC7B,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC;aACtB;SACF;QACD,6BAA6B,GAAG,KAAK,CAAC;QACtC,OAAO,WAAW,CAAC;IACrB,CAAC,CAAC;IACF,iCAAiC;IACjC,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,SAAS,CAAC,EAC9B,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,oBAAoB,EAAE,EAAE,GAAG,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,EACzE,cAAc,CAAC,SAAS,CAAC,EACzB,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC,EACvC,UAAU,CAAC,CAAC,CAAC,EAAE;QACb,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACjB,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CACH,CAAC;IAEF,OAAO;QACL,uBAAuB,CAAC,KAAU;YAChC,wBAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvC,CAAC;QACD,YAAY,CAAC,UAAuC;YAClD,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACjC,CAAC;QACD,eAAe,EAAE,SAAS;QAC1B,SAAS;YACP,OAAO,IAAI,YAAY,EAAE;iBACtB,GAAG,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC;iBAC1B,GAAG,CAAC,gBAAgB,CAAC,SAAS,EAAE,CAAC,CAAC;QACvC,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import {\r\n  ConnectableObservable,\r\n  EMPTY,\r\n  NextObserver,\r\n  Observable,\r\n  of,\r\n  ReplaySubject,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport {\r\n  catchError,\r\n  distinctUntilChanged,\r\n  filter,\r\n  map,\r\n  publishReplay,\r\n  switchAll,\r\n  switchMap,\r\n  tap,\r\n  withLatestFrom\r\n} from 'rxjs/operators';\r\nimport { RenderStrategy, StrategySelection } from './interfaces';\r\nimport { nameToStrategy } from './nameToStrategy';\r\nimport { DEFAULT_STRATEGY_NAME } from '../../render-strategies/strategies/strategies-map';\r\n\r\nexport interface RenderAware<U> extends Subscribable<U> {\r\n  nextPotentialObservable: (value: any) => void;\r\n  nextStrategy: (config: string | Observable<string>) => void;\r\n  activeStrategy$: Observable<RenderStrategy<U>>;\r\n}\r\n\r\n/**\r\n * RenderAware\r\n *\r\n * @description\r\n * This function returns an object that holds all the shared logic for the push pipe and the let directive\r\n * responsible for change detection\r\n * If you extend this class you need to implement how the update of the rendered value happens.\r\n * Also custom behaviour is something you need to implement in the extending class\r\n */\r\nexport function createRenderAware<U>(cfg: {\r\n  strategies: StrategySelection<U>;\r\n  resetObserver: NextObserver<void>;\r\n  updateObserver: NextObserver<U>;\r\n}): RenderAware<U | undefined | null> {\r\n  const strategyName$ = new ReplaySubject<string | Observable<string>>(1);\r\n  const strategy$: Observable<RenderStrategy<U>> = strategyName$.pipe(\r\n    distinctUntilChanged(),\r\n    switchMap(stringOrObservable =>\r\n      typeof stringOrObservable === 'string'\r\n        ? of(stringOrObservable)\r\n        : stringOrObservable\r\n    ),\r\n    nameToStrategy(cfg.strategies)\r\n  );\r\n\r\n  const observablesFromTemplate$ = new ReplaySubject<Observable<U>>(1);\r\n  const valuesFromTemplate$ = observablesFromTemplate$.pipe(\r\n    distinctUntilChanged()\r\n  );\r\n  let firstTemplateObservableChange = true;\r\n\r\n  const renderingEffect$ = valuesFromTemplate$.pipe(\r\n    // handle null | undefined assignment and new Observable reset\r\n    map(observable$ => {\r\n      if (observable$ === null) {\r\n        return of(null);\r\n      }\r\n      if (!firstTemplateObservableChange) {\r\n        cfg.resetObserver.next();\r\n        if (observable$ === undefined) {\r\n          return of(undefined);\r\n        }\r\n      }\r\n      firstTemplateObservableChange = false;\r\n      return observable$;\r\n    }),\r\n    // forward only observable values\r\n    filter(o$ => o$ !== undefined),\r\n    switchMap(o$ => o$.pipe(distinctUntilChanged(), tap(cfg.updateObserver))),\r\n    withLatestFrom(strategy$),\r\n    tap(([v, strat]) => strat.scheduleCD()),\r\n    catchError(e => {\r\n      console.error(e);\r\n      return EMPTY;\r\n    })\r\n  );\r\n\r\n  return {\r\n    nextPotentialObservable(value: any): void {\r\n      observablesFromTemplate$.next(value);\r\n    },\r\n    nextStrategy(nextConfig: string | Observable<string>): void {\r\n      strategyName$.next(nextConfig);\r\n    },\r\n    activeStrategy$: strategy$,\r\n    subscribe(): Subscription {\r\n      return new Subscription()\r\n        .add(strategy$.subscribe())\r\n        .add(renderingEffect$.subscribe());\r\n    }\r\n  };\r\n}\r\n"]}