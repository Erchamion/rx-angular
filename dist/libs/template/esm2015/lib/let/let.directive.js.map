{"version":3,"file":"let.directive.js","sourceRoot":"ng://@rx-angular/template/","sources":["lib/let/let.directive.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  ChangeDetectorRef,\r\n  Directive,\r\n  Input,\r\n  OnChanges,\r\n  OnDestroy,\r\n  OnInit,\r\n  SimpleChanges,\r\n  TemplateRef,\r\n  ViewContainerRef\r\n} from '@angular/core';\r\n\r\nimport {\r\n  NextObserver,\r\n  Observable,\r\n  ObservableInput,\r\n  Observer,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport { createRenderAware, RenderAware } from '../core';\r\nimport {\r\n  DEFAULT_STRATEGY_NAME,\r\n  getStrategies\r\n} from '../render-strategies/strategies/strategies-map';\r\n\r\nexport interface LetViewContext<T> {\r\n  // to enable `let` syntax we have to use $implicit (var; let v = var)\r\n  $implicit?: T;\r\n  // to enable `as` syntax we have to assign the directives selector (var as v)\r\n  rxLet?: T;\r\n  // set context var complete to true (var$; let e = $error)\r\n  $error?: boolean;\r\n  // set context var complete to true (var$; let c = $complete)\r\n  $complete?: boolean;\r\n}\r\n\r\n/**\r\n * @Directive LetDirective\r\n *\r\n * @description\r\n *\r\n * The `*rxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\r\n * It also helps with several internal processing under the hood.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n * ```html\r\n * <ng-container *ngIf=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * <app-number-special [number]=\"n\">\r\n * </app-number-special>\r\n * </ng-container>\r\n *  ```\r\n *\r\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\r\n *\r\n * Included Features:\r\n * - binding is always present. (`*ngIf=\"truthy$\"`)\r\n * - it takes away the multiple usages of the `async` or `push` pipe\r\n * - a unified/structured way of handling null and undefined\r\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or\r\n *   `ChangeDetectorRef.markForCheck`)\r\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or\r\n *   `ÉµdetectChanges`)\r\n * - distinct same values in a row (distinctUntilChanged operator),\r\n *\r\n * @usageNotes\r\n *\r\n * The `*rxLet` directive take over several things and makes it more convenient and save to work with streams in the\r\n *   template\r\n * `<ng-container *rxLet=\"observableNumber$ as c\"></ng-container>`\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n *\r\n * <ng-container *rxLet=\"observableNumber$; let n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n * ```\r\n *\r\n * In addition to that it provides us information from the whole observable context.\r\n * We can track the observables:\r\n * - next value\r\n * - error value\r\n * - complete base-state\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\r\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\r\n * </app-number>\r\n * <ng-container *ngIf=\"e\">\r\n * There is an error: {{e}}\r\n * </ng-container>\r\n * <ng-container *ngIf=\"c\">\r\n * Observable completed: {{c}}\r\n * </ng-container>\r\n * </ng-container>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n@Directive({ selector: '[rxLet]' })\r\nexport class LetDirective<U> implements OnInit, OnDestroy {\r\n  static ngTemplateGuard_rxLet: 'binding';\r\n\r\n  @Input()\r\n  set rxLet(potentialObservable: ObservableInput<U> | null | undefined) {\r\n    this.renderAware.nextPotentialObservable(potentialObservable);\r\n  }\r\n  @Input('rxLetStrategy')\r\n  set strategy(strategy: string | Observable<string> | undefined) {\r\n    this.renderAware.nextStrategy(strategy || DEFAULT_STRATEGY_NAME);\r\n  }\r\n\r\n  readonly strategies;\r\n  private embeddedView: any;\r\n  private readonly ViewContext: LetViewContext<U | undefined | null> = {\r\n    $implicit: undefined,\r\n    rxLet: undefined,\r\n    $error: false,\r\n    $complete: false\r\n  };\r\n\r\n  protected subscription: Unsubscribable;\r\n  readonly renderAware: RenderAware<U | null | undefined>;\r\n  private readonly resetObserver: NextObserver<void> = {\r\n    next: () => {\r\n      // if not initialized no need to set undefined\r\n      if (this.embeddedView) {\r\n        this.ViewContext.$implicit = undefined;\r\n        this.ViewContext.rxLet = undefined;\r\n        this.ViewContext.$error = false;\r\n        this.ViewContext.$complete = false;\r\n      }\r\n    }\r\n  };\r\n  private readonly updateObserver: Observer<U | null | undefined> = {\r\n    next: (value: U | null | undefined) => {\r\n      // to have initial rendering lazy\r\n      if (!this.embeddedView) {\r\n        this.createEmbeddedView();\r\n      }\r\n      this.ViewContext.$implicit = value;\r\n      this.ViewContext.rxLet = value;\r\n    },\r\n    error: (error: Error) => {\r\n      // to have initial rendering lazy\r\n      if (!this.embeddedView) {\r\n        this.createEmbeddedView();\r\n      }\r\n      this.ViewContext.$error = true;\r\n    },\r\n    complete: () => {\r\n      // to have initial rendering lazy\r\n      if (!this.embeddedView) {\r\n        this.createEmbeddedView();\r\n      }\r\n      this.ViewContext.$complete = true;\r\n    }\r\n  };\r\n\r\n  static ngTemplateContextGuard<U>(\r\n    dir: LetDirective<U>,\r\n    ctx: unknown | null | undefined\r\n  ): ctx is LetViewContext<U> {\r\n    return true;\r\n  }\r\n\r\n  constructor(\r\n    cdRef: ChangeDetectorRef,\r\n    private readonly templateRef: TemplateRef<LetViewContext<U>>,\r\n    private readonly viewContainerRef: ViewContainerRef\r\n  ) {\r\n    this.strategies = getStrategies<U>({ cdRef });\r\n\r\n    this.renderAware = createRenderAware<U>({\r\n      strategies: this.strategies,\r\n      resetObserver: this.resetObserver,\r\n      updateObserver: this.updateObserver\r\n    });\r\n    this.renderAware.nextStrategy(DEFAULT_STRATEGY_NAME);\r\n  }\r\n\r\n  ngOnInit() {\r\n    this.subscription = this.renderAware.subscribe();\r\n  }\r\n\r\n  createEmbeddedView() {\r\n    this.embeddedView = this.viewContainerRef.createEmbeddedView(\r\n      this.templateRef,\r\n      this.ViewContext\r\n    );\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.subscription.unsubscribe();\r\n    this.viewContainerRef.clear();\r\n  }\r\n}\r\n"]}