{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@rx-angular/template/lib/core/render-aware/nameToStrategy.ts","ng://@rx-angular/template/lib/core/render-aware/render-aware_creator.ts","ng://@rx-angular/template/lib/core/utils/get-global-this.ts","ng://@rx-angular/template/lib/core/utils/properties-weakmap.ts","ng://@rx-angular/template/lib/core/utils/zone-checks.ts","ng://@rx-angular/template/lib/core/utils/unpatched-promise.ts","ng://@rx-angular/template/lib/core/utils/make-zone-less.ts","ng://@rx-angular/template/lib/core/render-aware/coalescing-manager.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/operators/coalesceWith.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/scheduling/getPostTaskScheduler.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/scheduling/asapScheduler.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/scheduling/idleCallbackScheduler.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/scheduling/interfaces.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/scheduling/animationFrameScheduler.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/scheduling/priority-scheduler-map.ts","ng://@rx-angular/template/lib/render-strategies/static/static-coalesce.ts","ng://@rx-angular/template/lib/render-strategies/static/static-schedule.ts","ng://@rx-angular/template/lib/render-strategies/static/static-schedule-and-coalesced.ts","ng://@rx-angular/template/lib/render-strategies/strategies/native.strategy.ts","ng://@rx-angular/template/lib/render-strategies/strategies/local.strategy.ts","ng://@rx-angular/template/lib/render-strategies/strategies/global.strategy.ts","ng://@rx-angular/template/lib/render-strategies/strategies/strategies-map.ts","ng://@rx-angular/template/lib/render-strategies/strategies/noop.strategy.ts","ng://@rx-angular/template/lib/push/push.pipe.ts","ng://@rx-angular/template/lib/push/push.module.ts","ng://@rx-angular/template/lib/let/let.directive.ts","ng://@rx-angular/template/lib/let/let.module.ts","ng://@rx-angular/template/lib/unpatch/events/unpatch-event-list.ts","ng://@rx-angular/template/lib/unpatch/events/unpatch-events.directive.ts","ng://@rx-angular/template/lib/unpatch/events/unpatch-events.module.ts","ng://@rx-angular/template/lib/template.module.ts","ng://@rx-angular/template/lib/core/utils/view-engine-checks.ts","ng://@rx-angular/template/lib/render-strategies/rxjs/operators/renderChange.ts","ng://@rx-angular/template/lib/core/rxjs/operators/toObservableValue.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","nameToStrategy","strategies","o$","pipe","distinctUntilChanged","map","strategy","Error","createRenderAware","cfg","strategyName$","ReplaySubject","strategy$","switchMap","stringOrObservable","of","observablesFromTemplate$","valuesFromTemplate$","firstTemplateObservableChange","renderingEffect$","observable$","resetObserver","undefined","filter","tap","updateObserver","withLatestFrom","_a","_b","scheduleCD","catchError","console","EMPTY","nextPotentialObservable","nextStrategy","nextConfig","activeStrategy$","subscribe","Subscription","add","getGlobalThis","globalThis","self","window","createPropertiesWeakMap","getDefaults","propertyMap","WeakMap","getProps","getProperties","setProps","ctx","props","properties","entries","forEach","prop","set","defaults","propertiesPresent","get","property","hasKey","apiZonePatched","name","zoneDetectionCache","isNgZone","instance","cachedValue","calledApply","fn","runOutsideAngular","resolvedPromise","getUnpatchedResolvedPromise","__zone_symbol__Promise","resolve","Promise","getZoneUnPatchedApi","elem","unpatchEventListener","event","eventListeners","addEventListener","bind","listener","removeEventListener","coalescingContextPropertiesMap","numCoalescingSubscribers","createCoalesceManager","scope","remove","isCoalescing","coalesceWith","durationSelector","_scope","source","Observable","observer","rootSubscription","outerObserver","actionSubscription","latestValue","coa","tryEmitLatestValue","complete","createInnerObserver","PostTaskSchedulerPriority","unpatchedAsapScheduler","now","schedule","work","options","state","from","postTaskScheduler","scheduler","postTask","Date","setTimeout","PostTaskAction","_super","_this","delay","closed","_scheduler","getPostTaskScheduler","priority","asyncScheduler","isObject","action","then","unsubscribe","SchedulingPriority","cancelIdleCallback","idleId","warn","clearTimeout","requestIdleCallback","cb","start","didTimeout","timeRemaining","Math","max","IdleAction","idleScheduler","id","animationFrameTick","subscriber","unpatchedAnimationFrameScheduler","prioritySchedulerMap","animationFrame","animationFrameScheduler","asapScheduler","setInterval","idleCallback","userBlocking","userVisible","background","getScheduler","staticCoalesce","coalescingManager","tryExecuteWork","coalesceAndSchedule","createNativeStrategy","config","renderMethod","cdRef","markForCheck","behavior","createLocalNativeStrategy","detectChanges","createLocalStrategy","context","observeOn","createLocalCoalesceStrategy","createLocalCoalesceAndScheduleStrategy","createDetachStrategy","reattach","detach","createUserVisibleStrategy","createUserBlockingStrategy","createBackgroundStrategy","createIdleCallbackStrategy","createGlobalStrategy","markDirty","getStrategies","noop","native","global","getGlobalStrategies","local","localCoalesce","localCoalesceAndSchedule","localNative","getLocalStrategies","PushPipe","renderedValue","RenderAware","subscription","transform","potentialObservable","ngOnDestroy","core","ɵɵinjectPipeChangeDetectorRef","pure","PushModule","imports","declarations","exports","LetDirective","templateRef","viewContainerRef","ViewContext","$implicit","rxLet","$error","$complete","embeddedView","createEmbeddedView","renderAware","defineProperty","ngTemplateContextGuard","dir","ngOnInit","clear","ɵɵdirectiveInject","ChangeDetectorRef","TemplateRef","ViewContainerRef","selectors","inputs","LetModule","zonePatchedEvents","UnpatchEventsDirective","el","events$","BehaviorSubject","reapplyEventListenersZoneUnPatched","events","ev","nativeElement","ngAfterViewInit","eventList","ElementRef","UnpatchEventsModule","TemplateModule","Zone","ng","probe","v"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Observable } from 'rxjs';\r\nimport { distinctUntilChanged, map } from 'rxjs/operators';\r\nimport { RenderStrategy, StrategySelection } from './interfaces';\r\n\r\nexport function nameToStrategy<U>(strategies: StrategySelection<U>) {\r\n  return (o$: Observable<string>): Observable<RenderStrategy<U>> => {\r\n    return o$.pipe(\r\n      distinctUntilChanged(),\r\n      map(\r\n        (strategy: string): RenderStrategy<U> => {\r\n          const s = strategies[strategy];\r\n          if (!!s) {\r\n            return s;\r\n          }\r\n          throw new Error(`Strategy ${strategy} does not exist.`);\r\n        }\r\n      )\r\n    );\r\n  };\r\n}\r\n","import {\r\n  ConnectableObservable,\r\n  EMPTY,\r\n  NextObserver,\r\n  Observable,\r\n  of,\r\n  ReplaySubject,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription\r\n} from 'rxjs';\r\nimport {\r\n  catchError,\r\n  distinctUntilChanged,\r\n  filter,\r\n  map,\r\n  publishReplay,\r\n  switchAll,\r\n  switchMap,\r\n  tap,\r\n  withLatestFrom\r\n} from 'rxjs/operators';\r\nimport { RenderStrategy, StrategySelection } from './interfaces';\r\nimport { nameToStrategy } from './nameToStrategy';\r\nimport { DEFAULT_STRATEGY_NAME } from '../../render-strategies/strategies/strategies-map';\r\n\r\nexport interface RenderAware<U> extends Subscribable<U> {\r\n  nextPotentialObservable: (value: any) => void;\r\n  nextStrategy: (config: string | Observable<string>) => void;\r\n  activeStrategy$: Observable<RenderStrategy<U>>;\r\n}\r\n\r\n/**\r\n * RenderAware\r\n *\r\n * @description\r\n * This function returns an object that holds all the shared logic for the push pipe and the let directive\r\n * responsible for change detection\r\n * If you extend this class you need to implement how the update of the rendered value happens.\r\n * Also custom behaviour is something you need to implement in the extending class\r\n */\r\nexport function createRenderAware<U>(cfg: {\r\n  strategies: StrategySelection<U>;\r\n  resetObserver: NextObserver<void>;\r\n  updateObserver: NextObserver<U>;\r\n}): RenderAware<U | undefined | null> {\r\n  const strategyName$ = new ReplaySubject<string | Observable<string>>(1);\r\n  const strategy$: Observable<RenderStrategy<U>> = strategyName$.pipe(\r\n    distinctUntilChanged(),\r\n    switchMap(stringOrObservable =>\r\n      typeof stringOrObservable === 'string'\r\n        ? of(stringOrObservable)\r\n        : stringOrObservable\r\n    ),\r\n    nameToStrategy(cfg.strategies)\r\n  );\r\n\r\n  const observablesFromTemplate$ = new ReplaySubject<Observable<U>>(1);\r\n  const valuesFromTemplate$ = observablesFromTemplate$.pipe(\r\n    distinctUntilChanged()\r\n  );\r\n  let firstTemplateObservableChange = true;\r\n\r\n  const renderingEffect$ = valuesFromTemplate$.pipe(\r\n    // handle null | undefined assignment and new Observable reset\r\n    map(observable$ => {\r\n      if (observable$ === null) {\r\n        return of(null);\r\n      }\r\n      if (!firstTemplateObservableChange) {\r\n        cfg.resetObserver.next();\r\n        if (observable$ === undefined) {\r\n          return of(undefined);\r\n        }\r\n      }\r\n      firstTemplateObservableChange = false;\r\n      return observable$;\r\n    }),\r\n    // forward only observable values\r\n    filter(o$ => o$ !== undefined),\r\n    switchMap(o$ => o$.pipe(distinctUntilChanged(), tap(cfg.updateObserver))),\r\n    withLatestFrom(strategy$),\r\n    tap(([v, strat]) => strat.scheduleCD()),\r\n    catchError(e => {\r\n      console.error(e);\r\n      return EMPTY;\r\n    })\r\n  );\r\n\r\n  return {\r\n    nextPotentialObservable(value: any): void {\r\n      observablesFromTemplate$.next(value);\r\n    },\r\n    nextStrategy(nextConfig: string | Observable<string>): void {\r\n      strategyName$.next(nextConfig);\r\n    },\r\n    activeStrategy$: strategy$,\r\n    subscribe(): Subscription {\r\n      return new Subscription()\r\n        .add(strategy$.subscribe())\r\n        .add(renderingEffect$.subscribe());\r\n    }\r\n  };\r\n}\r\n","/**\r\n * @description\r\n *\r\n * A fallback for the new `globalThis` reference.\r\n *\r\n *  It should be used to replace `window` due to different environments in:\r\n *  - SSR (Server Side Rendering)\r\n *  - Tests\r\n *  - Browser\r\n *\r\n *  @return {globalThis} - A reference to globalThis. `window` in the Browser.\r\n */\r\nexport function getGlobalThis(): any {\r\n  return ((globalThis as any) || (self as any) || (window as any)) as any;\r\n}\r\n","type KeyOf<O> = keyof O & string & symbol & number;\r\n\r\n/*\r\n * createPropertiesWeakMap\r\n *\r\n * @param getDefaults: (o: O) => P\r\n * Example:\r\n *\r\n * export interface Properties {\r\n *   isCoalescing: boolean;\r\n * }\r\n *\r\n * const obj: object = {\r\n *   foo: 'bar',\r\n *   isCoalescing: 'weakMap version'\r\n * };\r\n *\r\n * const getDefaults = (ctx: object): Properties => ({isCoalescing: false});\r\n * const propsMap = createPropertiesWeakMap<object, Properties>(getDefaults);\r\n *\r\n * console.log('obj before:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props before:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"weakMap version\"}\r\n *\r\n * propsMap.setProps(obj, {isCoalescing: true});\r\n * console.log('obj after:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props after:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"true\"}\r\n * */\r\nexport function createPropertiesWeakMap<O extends object, P extends object>(\r\n  getDefaults: (o: O) => P\r\n) {\r\n  type K = KeyOf<P>;\r\n  const propertyMap = new WeakMap<O, P>();\r\n\r\n  return {\r\n    getProps: getProperties,\r\n    setProps: setProperties\r\n  };\r\n\r\n  function getProperties(ctx: O): P {\r\n    const defaults = getDefaults(ctx);\r\n    const propertiesPresent: P | undefined = propertyMap.get(ctx);\r\n    let properties: P;\r\n\r\n    if (propertiesPresent !== undefined) {\r\n      properties = propertiesPresent;\r\n    } else {\r\n      properties = {} as P;\r\n\r\n      (Object.entries(defaults) as [K, P[K]][]).forEach(\r\n        ([prop, value]): void => {\r\n          properties[prop] = hasKey(ctx, prop) ? ctx[prop] : value;\r\n        }\r\n      );\r\n\r\n      propertyMap.set(ctx, properties);\r\n    }\r\n    return properties;\r\n  }\r\n\r\n  function setProperties(ctx: O, props: Partial<P>): P {\r\n    const properties: P = getProperties(ctx);\r\n    (Object.entries(props) as [K, P[K]][]).forEach(([prop, value]) => {\r\n      properties[prop] = value;\r\n    });\r\n    propertyMap.set(ctx, properties);\r\n    return properties;\r\n  }\r\n\r\n  function hasKey(ctx: O, property: K): ctx is K {\r\n    return ctx[property] != null;\r\n  }\r\n}\r\n","import { getGlobalThis } from './get-global-this';\r\n\r\n/**\r\n * envZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks the window object `zone.js` was instantiated.\r\n * If so, the `window` object maintains a property named `Zone`.\r\n *\r\n * Here how Angular checks it: https://github.com/angular/angular/blob/master/packages/core/src/zone/ng_zone.ts#L123\r\n *\r\n * @return {boolean} - true if `zone.js` patched global APIs.\r\n *\r\n */\r\nexport function envZonePatched(): boolean {\r\n  return getGlobalThis().Zone !== undefined;\r\n}\r\n\r\n/**\r\n * apiZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks if a specific Browser API is patched by `zone.js`.\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @return {boolean} - true if `zone.js` patched the API in question.\r\n *\r\n */\r\nexport function apiZonePatched(name: string): boolean {\r\n  // if symbol is present, zone patched the API\r\n  return getGlobalThis()['__zone_symbol__' + name] !== undefined;\r\n}\r\n\r\nconst zoneDetectionCache = new WeakMap<any, boolean>();\r\n\r\n/**\r\n * isNgZone\r\n *\r\n * @description\r\n *\r\n * This function takes an instance of a class which implements the NgZone interface and checks if\r\n * its `runOutsideAngular()` function calls `apply()` on the function passed as parameter. This\r\n * means the Angular application that instantiated this service assumes it runs in a ZoneLess\r\n * environment, and therefore it's change detection will not be triggered by zone related logic.\r\n *\r\n * However, keep in mind this does not mean `zone.js` is not present.\r\n * The environment could still run in ZoneFull mode even if Angular turned it off.\r\n * Consider the situation of a Angular element configured for ZoneLess\r\n * environments is used in an Angular application relining on the zone mechanism.\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NgZone`.\r\n * @return {boolean} - true if instance is of type `NgZone`.\r\n *\r\n */\r\nexport function isNgZone(instance: any): boolean {\r\n  const cachedValue = zoneDetectionCache.get(instance);\r\n\r\n  if (cachedValue !== undefined) {\r\n    return cachedValue;\r\n  }\r\n\r\n  let calledApply = false;\r\n\r\n  function fn() {}\r\n  fn.apply = () => (calledApply = true);\r\n\r\n  instance.runOutsideAngular(fn);\r\n  zoneDetectionCache.set(instance, calledApply);\r\n\r\n  return calledApply;\r\n}\r\n\r\n/**\r\n * isNoopNgZone\r\n *\r\n *@description\r\n *\r\n * This function takes any instance of a class and checks\r\n * if the constructor name is equal to `NoopNgZone`.\r\n *\r\n * For more detailed information read the description of [isNgZone](#isngzone).\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NoopNgZone`.\r\n * @return {boolean} - true if instance is of type `NoopNgZone`.\r\n *\r\n */\r\nexport function isNoopNgZone(instance: any): boolean {\r\n  return !isNgZone(instance);\r\n}\r\n","/** A shared promise instance to cause a delay of one microtask */\r\nimport { getGlobalThis } from './get-global-this';\r\nimport { apiZonePatched } from './zone-checks';\r\n\r\nlet resolvedPromise: Promise<void> | null = null;\r\n\r\nexport function getUnpatchedResolvedPromise(): Promise<void> {\r\n  resolvedPromise =\r\n    resolvedPromise ||\r\n    (apiZonePatched('Promise')\r\n      ? (getGlobalThis().__zone_symbol__Promise.resolve() as Promise<void>)\r\n      : Promise.resolve());\r\n  return resolvedPromise;\r\n}\r\n","import { getGlobalThis } from './get-global-this';\r\nimport { apiZonePatched } from './zone-checks';\r\n\r\n/**\r\n * getZoneUnPatchedApi\r\n *\r\n * @description\r\n *\r\n * This function returns the zone un-patched API for the a specific Browser API.\r\n * If no element is passed the window is used instead\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @param elem {any} - The elem to get un-patched API from.\r\n * @return {Function} - The zone un-patched API in question.\r\n *\r\n */\r\nexport function getZoneUnPatchedApi(name: string, elem?: any): Function {\r\n  elem = elem || getGlobalThis();\r\n  return apiZonePatched(name) ? elem['__zone_symbol__' + name] : elem[name];\r\n}\r\n\r\n/**\r\n *\r\n * @description\r\n *\r\n * This function takes an elem and event and re-applies the listeners from the passed event to the\r\n * passed element with the zone un-patched version of it.\r\n *\r\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\r\n * @param event {string} - The name of the event from which to re-apply the listeners.\r\n *\r\n * @returns void\r\n */\r\nexport function unpatchEventListener(elem: HTMLElement, event: string): void {\r\n  const eventListeners = (elem as any).eventListeners(event);\r\n  // Return if no event listeners are present\r\n  if (!eventListeners) {\r\n    return;\r\n  }\r\n\r\n  const addEventListener = getZoneUnPatchedApi('addEventListener', elem).bind(\r\n    elem\r\n  );\r\n  eventListeners.forEach(listener => {\r\n    // Remove and reapply listeners with patched API\r\n    elem.removeEventListener(event, listener);\r\n    // Reapply listeners with un-patched API\r\n    addEventListener(event, listener);\r\n  });\r\n}\r\n","import { createPropertiesWeakMap } from '../utils';\r\n\r\ninterface CoalescingContextProps {\r\n  numCoalescingSubscribers: number;\r\n}\r\n\r\nconst coalescingContextPropertiesMap = createPropertiesWeakMap<\r\n  object,\r\n  CoalescingContextProps\r\n>(ctx => ({\r\n  numCoalescingSubscribers: 0\r\n}));\r\n\r\nexport function createCoalesceManager(\r\n  scope: object = {}\r\n): {\r\n  remove: () => void;\r\n  add: () => void;\r\n  isCoalescing: () => boolean;\r\n} {\r\n  return {\r\n    remove: removeSubscriber,\r\n    add: addSubscription,\r\n    isCoalescing\r\n  };\r\n\r\n  // Increments the number of subscriptions in a scope e.g. a class instance\r\n  function removeSubscriber(): void {\r\n    const numCoalescingSubscribers =\r\n      coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers -\r\n      1;\r\n    coalescingContextPropertiesMap.setProps(scope, {\r\n      numCoalescingSubscribers\r\n    });\r\n  }\r\n\r\n  // Decrements the number of subscriptions in a scope e.g. a class instance\r\n  function addSubscription(): void {\r\n    const numCoalescingSubscribers =\r\n      coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers +\r\n      1;\r\n    coalescingContextPropertiesMap.setProps(scope, {\r\n      numCoalescingSubscribers\r\n    });\r\n  }\r\n\r\n  // Checks if anybody else is already coalescing atm\r\n  function isCoalescing(): boolean {\r\n    return (\r\n      coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers >\r\n      0\r\n    );\r\n  }\r\n}\r\n","import {\r\n  MonoTypeOperatorFunction,\r\n  Observable,\r\n  Observer,\r\n  Subscribable,\r\n  SubscribableOrPromise,\r\n  Subscriber,\r\n  Subscription,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport { createCoalesceManager } from '../../../core/render-aware/coalescing-manager';\r\n\r\n/**\r\n * @description\r\n * Limits the number of synchronous emitted a value from the source Observable to\r\n * one emitted value per\r\n *   [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats\r\n *   this process for every tick of the browsers event loop.\r\n *\r\n * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.\r\n * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope\r\n *   coalescing.\r\n *\r\n * @param {function(value: T): SubscribableOrPromise} durationSelector - A function\r\n * that receives a value from the source Observable, for computing the silencing\r\n * duration for each source value, returned as an Observable or a Promise.\r\n * It defaults to `requestAnimationFrame` as durationSelector.\r\n * @param {Object} config - A configuration object to define `leading` and `trailing` behavior and the context object.\r\n * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.\r\n * @return {Observable<T>} An Observable that performs the coalesce operation to\r\n * limit the rate of emissions from the source.\r\n *\r\n * @usageNotes\r\n * Emit clicks at a rate of at most one click per second\r\n * ```ts\r\n * import { fromEvent, animationFrames } from 'rxjs';\r\n * import { coalesce } from 'ngRx/component';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(coalesce(ev => animationFrames));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n */\r\nexport function coalesceWith<T>(\r\n  durationSelector: Subscribable<any>,\r\n  scope?: object\r\n): MonoTypeOperatorFunction<T> {\r\n  const _scope = scope || {};\r\n  return source => {\r\n    const o$ = new Observable<T>(observer => {\r\n      const rootSubscription = new Subscription();\r\n      rootSubscription.add(\r\n        source.subscribe(createInnerObserver(observer, rootSubscription))\r\n      );\r\n      return rootSubscription;\r\n    });\r\n\r\n    return o$;\r\n\r\n    function createInnerObserver(\r\n      outerObserver: Subscriber<T>,\r\n      rootSubscription: Subscription\r\n    ): Observer<T> {\r\n      let actionSubscription: Unsubscribable;\r\n      let latestValue: T | undefined;\r\n      const coa = createCoalesceManager(_scope);\r\n      const tryEmitLatestValue = () => {\r\n        coa.remove();\r\n        if (!coa.isCoalescing()) {\r\n          outerObserver.next(latestValue);\r\n        }\r\n      };\r\n      return {\r\n        complete: () => {\r\n          if (actionSubscription) {\r\n            tryEmitLatestValue();\r\n          }\r\n          outerObserver.complete();\r\n        },\r\n        error: error => outerObserver.error(error),\r\n        next: value => {\r\n          latestValue = value;\r\n          if (!actionSubscription) {\r\n            coa.add();\r\n            actionSubscription = durationSelector.subscribe({\r\n              next: () => {\r\n                tryEmitLatestValue();\r\n                actionSubscription = undefined;\r\n              },\r\n              complete: () => {\r\n                if (actionSubscription) {\r\n                  tryEmitLatestValue();\r\n                  actionSubscription = undefined;\r\n                }\r\n              }\r\n            });\r\n            rootSubscription.add(actionSubscription);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n","import {\r\n  asyncScheduler,\r\n  SchedulerAction,\r\n  SchedulerLike,\r\n  Subscription\r\n} from 'rxjs';\r\nimport { isObject } from 'util';\r\n\r\n/**\r\n *\r\n * Implementation based on rxjs-etc => IdleScheduler\r\n *\r\n */\r\n\r\nexport enum PostTaskSchedulerPriority {\r\n  background = 'background',\r\n  userBlocking = 'user-blocking',\r\n  userVisible = 'user-visible'\r\n}\r\n\r\ninterface PostTaskScheduler {\r\n  postTask<T>(cb: () => void, options: SchedulerPostTaskOptions): Promise<T>;\r\n}\r\n\r\ninterface SchedulerPostTaskOptions {\r\n  priority: PostTaskSchedulerPriority | string | null;\r\n  delay: number;\r\n  signal?: any;\r\n}\r\n\r\nexport const postTaskScheduler: PostTaskScheduler =\r\n  typeof window !== 'undefined'\r\n    ? (window as any).scheduler || {\r\n        postTask<T>(options: SchedulerPostTaskOptions): Promise<T> {\r\n          const start = Date.now();\r\n          return new Promise(resolve => {\r\n            setTimeout(function() {\r\n              console.error(\r\n                'postTask not implemented. Use setTimeout as fallback'\r\n              );\r\n              resolve();\r\n            }, 1);\r\n          });\r\n        }\r\n      }\r\n    : () => {};\r\n\r\nclass PostTaskAction<T> extends Subscription {\r\n  _scheduler;\r\n  constructor(private work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super();\r\n  }\r\n\r\n  schedule(state?: T, delay?: number) {\r\n    if (this.closed) {\r\n      return this;\r\n    }\r\n    return this._scheduler.schedule(this.work, delay, state);\r\n  }\r\n}\r\n\r\nexport function getPostTaskScheduler(\r\n  priority: PostTaskSchedulerPriority\r\n): SchedulerLike {\r\n  return ({\r\n    now() {\r\n      return asyncScheduler.now();\r\n    },\r\n    schedule<T>(\r\n      work: (this: SchedulerAction<T>, state?: T) => void,\r\n      options: SchedulerPostTaskOptions = {} as SchedulerPostTaskOptions,\r\n      state?: T\r\n    ): Subscription {\r\n      if (isObject(options) && (options as SchedulerPostTaskOptions).delay) {\r\n        return asyncScheduler.schedule(\r\n          work,\r\n          (options as SchedulerPostTaskOptions).delay,\r\n          state\r\n        );\r\n      }\r\n\r\n      options = { ...options, priority };\r\n\r\n      const action = new PostTaskAction(work);\r\n      // weired hack\r\n      action._scheduler = this;\r\n\r\n      const promise = postTaskScheduler\r\n        .postTask(() => {}, options)\r\n        .then(() => {\r\n          try {\r\n            work.call(action, state);\r\n          } catch (error) {\r\n            action.unsubscribe();\r\n            throw error;\r\n          }\r\n        });\r\n      action.add(() => {\r\n        throw new Error('not implemented');\r\n      });\r\n      return action;\r\n    }\r\n  } as unknown) as SchedulerLike;\r\n}\r\n","import { from, SchedulerLike, Subscription } from 'rxjs';\r\nimport { getUnpatchedResolvedPromise } from '../../../core';\r\n\r\nexport const unpatchedAsapScheduler: SchedulerLike = {\r\n  now() {\r\n    return 0;\r\n  },\r\n  schedule(\r\n    work: (...args: any[]) => void,\r\n    options?: number,\r\n    state?: any\r\n  ): Subscription {\r\n    return from(getUnpatchedResolvedPromise()).subscribe(() => work(state));\r\n  }\r\n};\r\n","import {\r\n  asyncScheduler,\r\n  SchedulerAction,\r\n  SchedulerLike,\r\n  Subscription\r\n} from 'rxjs';\r\n\r\n/**\r\n *\r\n * Implementation based on rxjs-etc => IdleScheduler\r\n *\r\n */\r\ntype IdleId = ReturnType<typeof setTimeout>;\r\n\r\ntype RequestIdleCallbackHandle = any;\r\n\r\ninterface RequestIdleCallbackOptions {\r\n  timeout: number;\r\n}\r\n\r\ninterface RequestIdleCallbackDeadline {\r\n  readonly didTimeout: boolean;\r\n  timeRemaining: () => number;\r\n}\r\n\r\ntype RequestIdleCallback = (\r\n  callback: (deadline: RequestIdleCallbackDeadline) => void,\r\n  opts?: RequestIdleCallbackOptions\r\n) => RequestIdleCallbackHandle;\r\n\r\ntype CancelIdleCallback = (idleId: IdleId) => void;\r\n\r\nexport const cancelIdleCallback: CancelIdleCallback =\r\n  typeof window !== 'undefined'\r\n    ? (window as any).cancelIdleCallback ||\r\n      function(idleId: IdleId): void {\r\n        console.warn('Fake cancelIdleCallback used');\r\n        clearTimeout(idleId);\r\n      }\r\n    : () => {};\r\n\r\nexport const requestIdleCallback: RequestIdleCallback =\r\n  typeof window !== 'undefined'\r\n    ? (window as any).requestIdleCallback ||\r\n      function(cb: Function) {\r\n        console.warn('Fake requestIdleCallback used');\r\n        const start = Date.now();\r\n        return setTimeout(function() {\r\n          cb({\r\n            didTimeout: false,\r\n            timeRemaining: function() {\r\n              return Math.max(0, 50 - (Date.now() - start));\r\n            }\r\n          });\r\n        }, 1);\r\n      }\r\n    : () => {};\r\n\r\nclass IdleAction<T> extends Subscription {\r\n  constructor(private work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super();\r\n  }\r\n\r\n  schedule(state?: T, delay?: number) {\r\n    if (this.closed) {\r\n      return this;\r\n    }\r\n    return idleScheduler.schedule(this.work, delay, state);\r\n  }\r\n}\r\n\r\nexport const idleScheduler: SchedulerLike = {\r\n  now() {\r\n    return asyncScheduler.now();\r\n  },\r\n  schedule<T>(\r\n    work: (this: SchedulerAction<T>, state?: T) => void,\r\n    delay?: number,\r\n    state?: T\r\n  ): Subscription {\r\n    if (delay) {\r\n      return asyncScheduler.schedule(work, delay, state);\r\n    }\r\n\r\n    const action = new IdleAction(work);\r\n    const id = requestIdleCallback(() => {\r\n      try {\r\n        work.call(action, state);\r\n      } catch (error) {\r\n        action.unsubscribe();\r\n        throw error;\r\n      }\r\n    });\r\n    action.add(() => cancelIdleCallback(id));\r\n    return action;\r\n  }\r\n};\r\n","export enum SchedulingPriority {\r\n  animationFrame = 'animationFrame',\r\n  Promise = 'Promise',\r\n  idleCallback = 'idleCallback',\r\n  userBlocking = 'userBlocking',\r\n  userVisible = 'userVisible',\r\n  background = 'background',\r\n  setInterval = 'setInterval'\r\n}\r\n","import { Observable, SchedulerLike, Subscription } from 'rxjs';\r\nimport { getZoneUnPatchedApi } from '../../../core';\r\n\r\nconst animationFrameTick = new Observable(subscriber => {\r\n  let i = 0;\r\n  const id = getZoneUnPatchedApi('requestAnimationFrame')(() => {\r\n    subscriber.next(++i);\r\n  });\r\n\r\n  return () => {\r\n    getZoneUnPatchedApi('cancelAnimationFrame')(id);\r\n  };\r\n});\r\n\r\nexport const unpatchedAnimationFrameScheduler: SchedulerLike = {\r\n  now() {\r\n    return 0;\r\n  },\r\n  schedule(\r\n    work: (...args: any[]) => void,\r\n    options?: number,\r\n    state?: any\r\n  ): Subscription {\r\n    return animationFrameTick.subscribe(() => work(state));\r\n  }\r\n};\r\n","import {\r\n  animationFrameScheduler,\r\n  asapScheduler,\r\n  asyncScheduler,\r\n  SchedulerLike\r\n} from 'rxjs';\r\nimport { SchedulingPriority } from './interfaces';\r\nimport {\r\n  getPostTaskScheduler,\r\n  PostTaskSchedulerPriority\r\n} from './getPostTaskScheduler';\r\nimport { idleScheduler } from './idleCallbackScheduler';\r\n\r\nexport const prioritySchedulerMap: { [name: string]: SchedulerLike } = {\r\n  animationFrame: animationFrameScheduler,\r\n  Promise: asapScheduler,\r\n  setInterval: asyncScheduler,\r\n  idleCallback: idleScheduler,\r\n  userBlocking: getPostTaskScheduler(PostTaskSchedulerPriority.userBlocking),\r\n  userVisible: getPostTaskScheduler(PostTaskSchedulerPriority.userVisible),\r\n  background: getPostTaskScheduler(PostTaskSchedulerPriority.background)\r\n};\r\n\r\nexport function getScheduler(priority: SchedulingPriority): SchedulerLike {\r\n  if (!prioritySchedulerMap.hasOwnProperty(priority)) {\r\n    throw new Error(`priority ${priority} is not present in prioritiesMap`);\r\n  }\r\n  return prioritySchedulerMap[priority];\r\n}\r\n","import { Subscribable } from 'rxjs';\r\nimport { createCoalesceManager } from '../../core/render-aware/coalescing-manager';\r\n\r\nexport function staticCoalesce<T>(\r\n  work: () => T,\r\n  durationSelector: Subscribable<any>,\r\n  scope: object = {}\r\n): void {\r\n  const coalescingManager = createCoalesceManager(scope);\r\n  if (!coalescingManager.isCoalescing()) {\r\n    coalescingManager.add();\r\n    durationSelector.subscribe(() => {\r\n      tryExecuteWork();\r\n    });\r\n  }\r\n\r\n  // =====\r\n\r\n  function tryExecuteWork() {\r\n    coalescingManager.remove();\r\n    if (!coalescingManager.isCoalescing()) {\r\n      return work();\r\n    }\r\n  }\r\n}\r\n","import { Subscription } from 'rxjs';\r\nimport { getScheduler } from '../rxjs/scheduling/priority-scheduler-map';\r\nimport { SchedulingPriority } from '../rxjs/scheduling/interfaces';\r\n\r\nexport function schedule(\r\n  work: () => void,\r\n  priority?: SchedulingPriority\r\n): Subscription {\r\n  return getScheduler(priority).schedule(() => work());\r\n}\r\n","import { from } from 'rxjs';\r\nimport { staticCoalesce } from './static-coalesce';\r\nimport { schedule } from './static-schedule';\r\nimport { SchedulingPriority } from '../rxjs/scheduling/interfaces';\r\nimport { getUnpatchedResolvedPromise } from '../../core/utils/unpatched-promise';\r\n\r\nexport function coalesceAndSchedule(\r\n  work: () => void,\r\n  priority: SchedulingPriority,\r\n  scope: object = {}\r\n): void {\r\n  const durationSelector = from(getUnpatchedResolvedPromise());\r\n  const scheduledWork = () => schedule(work, priority);\r\n  staticCoalesce(scheduledWork, durationSelector, scope);\r\n}\r\n","import { RenderStrategy, RenderStrategyFactoryConfig } from '../../core';\r\n\r\n/**\r\n * Native Strategy\r\n * @description\r\n *\r\n * This strategy mirrors Angular's built-in `async` pipe.\r\n * This means for every emitted value `ChangeDetectorRef#markForCheck` is called.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `native`    | ❌/❌         | mFC / mFC           | ❌               |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nexport function createNativeStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  return {\r\n    name: 'native',\r\n    renderMethod: config.cdRef.markForCheck,\r\n    behavior: o => o,\r\n    scheduleCD: () => {\r\n      config.cdRef.markForCheck();\r\n    }\r\n  };\r\n}\r\n","import { coalesceAndSchedule, staticCoalesce } from '../static';\r\nimport { SchedulingPriority } from '../rxjs/scheduling/interfaces';\r\nimport { getUnpatchedResolvedPromise } from '../../core/utils/unpatched-promise';\r\nimport { from, Observable } from 'rxjs';\r\nimport { getScheduler } from '../rxjs/scheduling/priority-scheduler-map';\r\nimport { observeOn } from 'rxjs/operators';\r\nimport {\r\n  RenderStrategy,\r\n  RenderStrategyFactoryConfig\r\n} from '../../core/render-aware/interfaces';\r\nimport { coalesceWith } from '../rxjs/operators/coalesceWith';\r\nimport {\r\n  postTaskScheduler,\r\n  PostTaskSchedulerPriority\r\n} from '../rxjs/scheduling/getPostTaskScheduler';\r\n\r\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `local`    | ✔/✔ ️        | dC / ɵDC            | ✔ ️ + C/ LV     |\r\n * | `detach`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `postTask` | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `idleCallback` | ❌/✔ ️   | mFC  / ɵMD          | ❌               |\r\n *\r\n */\r\n\r\nexport function getLocalStrategies<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): { [strategy: string]: RenderStrategy<T> } {\r\n  return {\r\n    local: createLocalStrategy<T>(config),\r\n    localCoalesce: createLocalCoalesceStrategy<T>(config),\r\n    localCoalesceAndSchedule: createLocalCoalesceAndScheduleStrategy<T>(config),\r\n    localNative: createLocalNativeStrategy<T>(config),\r\n    detach: createDetachStrategy(config),\r\n    userVisible: createUserVisibleStrategy(config),\r\n    userBlocking: createUserBlockingStrategy(config),\r\n    background: createBackgroundStrategy(config),\r\n    idleCallback: createIdleCallbackStrategy(config)\r\n  };\r\n}\r\n\r\nexport function createLocalNativeStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o => o.pipe();\r\n  const scheduleCD = () => renderMethod();\r\n\r\n  return {\r\n    name: 'localNative',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\n/**\r\n *  Local Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵlocal`    | ✔️/✔️    | dC / dC             | ✔️ + C         |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nexport function createLocalStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = from(getUnpatchedResolvedPromise());\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.animationFrame;\r\n  const scheduler = getScheduler(priority);\r\n\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n\r\n  return {\r\n    name: 'local',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\nexport function createLocalCoalesceStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = from(getUnpatchedResolvedPromise());\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.animationFrame;\r\n  const scheduler = getScheduler(priority);\r\n\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n\r\n  return {\r\n    name: 'localCoalesce',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\nexport function createLocalCoalesceAndScheduleStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = from(getUnpatchedResolvedPromise());\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.animationFrame;\r\n  const scheduler = getScheduler(priority);\r\n\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n\r\n  return {\r\n    name: 'localCoalesceAndSchedule',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\n/**\r\n *  Detach Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵdetach`     | ✔️/✔️          | dC / ɵDC            | ✔️ + C/ LV       |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nexport function createDetachStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = from(getUnpatchedResolvedPromise());\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.animationFrame;\r\n  const scheduler = getScheduler(priority);\r\n\r\n  const renderMethod = () => {\r\n    config.cdRef.reattach();\r\n    config.cdRef.detectChanges();\r\n    config.cdRef.detach();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n\r\n  return {\r\n    name: 'detach',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\n/**\r\n *  PostTask - Priority UserVisible Strategy\r\n *\r\n */\r\nexport function createUserVisibleStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = new Observable(subscriber => {\r\n    from(\r\n      postTaskScheduler.postTask(() => void 0, {\r\n        priority: PostTaskSchedulerPriority.userVisible,\r\n        delay: 0\r\n      })\r\n    ).subscribe(subscriber);\r\n  });\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.background;\r\n  const scheduler = getScheduler(priority);\r\n\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n\r\n  return {\r\n    name: 'userVisible',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\n/**\r\n *  PostTask - Priority UserBlocking Strategy\r\n *\r\n */\r\nexport function createUserBlockingStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = new Observable(subscriber => {\r\n    from(\r\n      postTaskScheduler.postTask(() => void 0, {\r\n        priority: PostTaskSchedulerPriority.userVisible,\r\n        delay: 0\r\n      })\r\n    ).subscribe(subscriber);\r\n  });\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.background;\r\n  const scheduler = getScheduler(priority);\r\n\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => {\r\n    staticCoalesce(renderMethod, durationSelector, scope);\r\n    // coalesceAndSchedule(renderMethod, priority, scope);\r\n  };\r\n\r\n  return {\r\n    name: 'userBlocking',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\n/**\r\n *  PostTask - Priority Background Strategy\r\n *\r\n */\r\nexport function createBackgroundStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = new Observable(subscriber => {\r\n    from(\r\n      postTaskScheduler.postTask(() => void 0, {\r\n        priority: PostTaskSchedulerPriority.userVisible,\r\n        delay: 0\r\n      })\r\n    ).subscribe(subscriber);\r\n  });\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.background;\r\n  const scheduler = getScheduler(priority);\r\n\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => {\r\n    staticCoalesce(renderMethod, durationSelector, scope);\r\n    // coalesceAndSchedule(renderMethod, priority, scope);\r\n  };\r\n  return {\r\n    name: 'background',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n\r\n/**\r\n *  IdleCallback Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges is used the coalescing described in `ɵlocal` is implemented here.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵdetach`     | ✔️/✔️          | dC / ɵDC            | ✔️ + C/ LV       |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nexport function createIdleCallbackStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const durationSelector = from(getUnpatchedResolvedPromise());\r\n  const scope = (config.cdRef as any).context;\r\n  const priority = SchedulingPriority.idleCallback;\r\n  const scheduler = getScheduler(priority);\r\n  const renderMethod = () => {\r\n    config.cdRef.detectChanges();\r\n  };\r\n  const behavior = o =>\r\n    o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n  const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n\r\n  return {\r\n    name: 'idleCallback',\r\n    renderMethod,\r\n    behavior,\r\n    scheduleCD\r\n  };\r\n}\r\n","import { ɵmarkDirty as markDirty } from '@angular/core';\r\nimport {\r\n  RenderStrategy,\r\n  RenderStrategyFactoryConfig\r\n} from '../../core/render-aware/interfaces';\r\n\r\nexport function getGlobalStrategies<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): { [strategy: string]: RenderStrategy<T> } {\r\n  return {\r\n    global: createGlobalStrategy<T>(config)\r\n  };\r\n}\r\n\r\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `global`   | ❌/✔ ️        | mFC  / ɵMD          | ❌               |\r\n *\r\n */\r\n\r\n/**\r\n *\r\n * Global Strategy\r\n *\r\n * This strategy is rendering the application root and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing       |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `global`   | ❌/✔️       | mFC / ɵMD           | ❌                |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nexport function createGlobalStrategy<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): RenderStrategy<T> {\r\n  const renderMethod = () => markDirty((config.cdRef as any).context);\r\n\r\n  return {\r\n    name: 'global',\r\n    renderMethod,\r\n    behavior: o => o,\r\n    scheduleCD: () => renderMethod()\r\n  };\r\n}\r\n","import {\r\n  RenderStrategy,\r\n  RenderStrategyFactoryConfig\r\n} from '../../core/render-aware/interfaces';\r\nimport { createNoopStrategy } from './noop.strategy';\r\nimport { createNativeStrategy } from './native.strategy';\r\nimport { getLocalStrategies } from './local.strategy';\r\nimport { getGlobalStrategies } from './global.strategy';\r\n\r\nexport const DEFAULT_STRATEGY_NAME = 'local';\r\n\r\nexport function getStrategies<T>(\r\n  config: RenderStrategyFactoryConfig\r\n): { [strategy: string]: RenderStrategy<T> } {\r\n  return {\r\n    noop: createNoopStrategy<T>(),\r\n    native: createNativeStrategy<T>(config),\r\n    ...getGlobalStrategies(config),\r\n    ...getLocalStrategies(config)\r\n  };\r\n}\r\n\r\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `noop`      | ❌/❌          | no rendering        | ❌               |\r\n * | `native`    | ❌/❌          | mFC / mFC           | ❌               |\r\n * | `global`    | ❌/✔ ️       | mFC  / ɵMD           | ❌               |\r\n * | `local`     | ✔/✔ ️        | dC / ɵDC            | ✔ ️ + C/ LV     |\r\n * | `ɵglobal`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `ɵlocal`    | ✔/✔ ️       | dC / ɵDC             | ✔ ️ + C/ LV     |\r\n * | `ɵdetach`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n *\r\n */\r\n","import {\r\n  RenderStrategy,\r\n  RenderStrategyFactoryConfig\r\n} from '../../core/render-aware/interfaces';\r\n\r\n/**\r\n * Noop Strategy\r\n *\r\n * This strategy is does nothing. It serves for debugging only\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `noop`      | ❌/❌         | no rendering        | ❌               |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nexport function createNoopStrategy<T>(): RenderStrategy<T> {\r\n  return {\r\n    name: 'noop',\r\n    renderMethod: () => {},\r\n    behavior: o => o,\r\n    scheduleCD: () => {}\r\n  };\r\n}\r\n","import {\r\n  ChangeDetectorRef,\r\n  OnDestroy,\r\n  Pipe,\r\n  PipeTransform\r\n} from '@angular/core';\r\nimport {\r\n  NextObserver,\r\n  Observable,\r\n  ObservableInput,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport { RenderAware, createRenderAware } from '../core';\r\nimport { getStrategies } from '../render-strategies';\r\nimport { DEFAULT_STRATEGY_NAME } from '../render-strategies/strategies/strategies-map';\r\n\r\n/**\r\n * @Pipe PushPipe\r\n *\r\n * @description\r\n *\r\n * The `push` pipe serves as a drop-in replacement for the `async` pipe.\r\n * It contains intelligent handling of change detection to enable us\r\n * running in zone-full as well as zone-less mode without any changes to the code.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n *  ```html\r\n *  {{observable$ | async}}\r\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | async\"></component>\r\n * ```\r\n *\r\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\r\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked\r\n *     components.\r\n *\r\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\r\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\r\n *\r\n * `push` pipe solves that problem.\r\n *\r\n * Included Features:\r\n *  - Take observables or promises, retrieve their values and render the value to the template\r\n *  - Handling null and undefined values in a clean unified/structured way\r\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\r\n *  - Distinct same values in a row to increase performance\r\n *  - Coalescing of change detection calls to boost performance\r\n *\r\n * @usageNotes\r\n *\r\n * `push` pipe solves that problem. It can be used like shown here:\r\n * ```html\r\n * {{observable$ | push}}\r\n * <ng-container *ngIf=\"observable$ | push as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | push\"></component>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n@Pipe({ name: 'push', pure: false })\r\nexport class PushPipe<S> implements PipeTransform, OnDestroy {\r\n  private renderedValue: S | null | undefined;\r\n\r\n  private readonly subscription: Unsubscribable;\r\n  private readonly RenderAware: RenderAware<S | null | undefined>;\r\n  private readonly resetObserver: NextObserver<void> = {\r\n    next: () => {\r\n      this.renderedValue = undefined;\r\n    }\r\n  };\r\n  private readonly updateObserver: NextObserver<S | null | undefined> = {\r\n    next: (value: S | null | undefined) => (this.renderedValue = value)\r\n  };\r\n\r\n  constructor(cdRef: ChangeDetectorRef) {\r\n    this.RenderAware = createRenderAware<S>({\r\n      strategies: getStrategies<S>({ cdRef }),\r\n      updateObserver: this.updateObserver,\r\n      resetObserver: this.resetObserver\r\n    });\r\n    this.subscription = this.RenderAware.subscribe();\r\n  }\r\n\r\n  transform<T>(\r\n    potentialObservable: null,\r\n    config?: string | Observable<string>\r\n  ): null;\r\n  transform<T>(\r\n    potentialObservable: undefined,\r\n    config?: string | Observable<string>\r\n  ): undefined;\r\n  transform<T>(\r\n    potentialObservable: ObservableInput<T>,\r\n    config?: string | Observable<string>\r\n  ): T;\r\n  transform<T>(\r\n    potentialObservable: ObservableInput<T> | null | undefined,\r\n    config: string | Observable<string> | undefined\r\n  ): T | null | undefined {\r\n    const strategy = config || DEFAULT_STRATEGY_NAME;\r\n    this.RenderAware.nextStrategy(strategy);\r\n    this.RenderAware.nextPotentialObservable(potentialObservable);\r\n    return this.renderedValue as any;\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.subscription.unsubscribe();\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { PushPipe } from './push.pipe';\r\nconst DECLARATIONS = [PushPipe];\r\n@NgModule({\r\n  declarations: DECLARATIONS,\r\n  imports: [],\r\n  exports: DECLARATIONS\r\n})\r\nexport class PushModule {}\r\n","import {\r\n  ChangeDetectorRef,\r\n  Directive,\r\n  Input,\r\n  OnChanges,\r\n  OnDestroy,\r\n  OnInit,\r\n  SimpleChanges,\r\n  TemplateRef,\r\n  ViewContainerRef\r\n} from '@angular/core';\r\n\r\nimport {\r\n  NextObserver,\r\n  Observable,\r\n  ObservableInput,\r\n  Observer,\r\n  Unsubscribable\r\n} from 'rxjs';\r\nimport { createRenderAware, RenderAware } from '../core';\r\nimport {\r\n  DEFAULT_STRATEGY_NAME,\r\n  getStrategies\r\n} from '../render-strategies/strategies/strategies-map';\r\n\r\nexport interface LetViewContext<T> {\r\n  // to enable `let` syntax we have to use $implicit (var; let v = var)\r\n  $implicit?: T;\r\n  // to enable `as` syntax we have to assign the directives selector (var as v)\r\n  rxLet?: T;\r\n  // set context var complete to true (var$; let e = $error)\r\n  $error?: boolean;\r\n  // set context var complete to true (var$; let c = $complete)\r\n  $complete?: boolean;\r\n}\r\n\r\n/**\r\n * @Directive LetDirective\r\n *\r\n * @description\r\n *\r\n * The `*rxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\r\n * It also helps with several internal processing under the hood.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n * ```html\r\n * <ng-container *ngIf=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * <app-number-special [number]=\"n\">\r\n * </app-number-special>\r\n * </ng-container>\r\n *  ```\r\n *\r\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\r\n *\r\n * Included Features:\r\n * - binding is always present. (`*ngIf=\"truthy$\"`)\r\n * - it takes away the multiple usages of the `async` or `push` pipe\r\n * - a unified/structured way of handling null and undefined\r\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or\r\n *   `ChangeDetectorRef.markForCheck`)\r\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or\r\n *   `ɵdetectChanges`)\r\n * - distinct same values in a row (distinctUntilChanged operator),\r\n *\r\n * @usageNotes\r\n *\r\n * The `*rxLet` directive take over several things and makes it more convenient and save to work with streams in the\r\n *   template\r\n * `<ng-container *rxLet=\"observableNumber$ as c\"></ng-container>`\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n *\r\n * <ng-container *rxLet=\"observableNumber$; let n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n * ```\r\n *\r\n * In addition to that it provides us information from the whole observable context.\r\n * We can track the observables:\r\n * - next value\r\n * - error value\r\n * - complete base-state\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\r\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\r\n * </app-number>\r\n * <ng-container *ngIf=\"e\">\r\n * There is an error: {{e}}\r\n * </ng-container>\r\n * <ng-container *ngIf=\"c\">\r\n * Observable completed: {{c}}\r\n * </ng-container>\r\n * </ng-container>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n@Directive({ selector: '[rxLet]' })\r\nexport class LetDirective<U> implements OnInit, OnDestroy {\r\n  static ngTemplateGuard_rxLet: 'binding';\r\n\r\n  @Input()\r\n  set rxLet(potentialObservable: ObservableInput<U> | null | undefined) {\r\n    this.renderAware.nextPotentialObservable(potentialObservable);\r\n  }\r\n  @Input('rxLetStrategy')\r\n  set strategy(strategy: string | Observable<string> | undefined) {\r\n    this.renderAware.nextStrategy(strategy || DEFAULT_STRATEGY_NAME);\r\n  }\r\n\r\n  readonly strategies;\r\n  private embeddedView: any;\r\n  private readonly ViewContext: LetViewContext<U | undefined | null> = {\r\n    $implicit: undefined,\r\n    rxLet: undefined,\r\n    $error: false,\r\n    $complete: false\r\n  };\r\n\r\n  protected subscription: Unsubscribable;\r\n  readonly renderAware: RenderAware<U | null | undefined>;\r\n  private readonly resetObserver: NextObserver<void> = {\r\n    next: () => {\r\n      // if not initialized no need to set undefined\r\n      if (this.embeddedView) {\r\n        this.ViewContext.$implicit = undefined;\r\n        this.ViewContext.rxLet = undefined;\r\n        this.ViewContext.$error = false;\r\n        this.ViewContext.$complete = false;\r\n      }\r\n    }\r\n  };\r\n  private readonly updateObserver: Observer<U | null | undefined> = {\r\n    next: (value: U | null | undefined) => {\r\n      // to have initial rendering lazy\r\n      if (!this.embeddedView) {\r\n        this.createEmbeddedView();\r\n      }\r\n      this.ViewContext.$implicit = value;\r\n      this.ViewContext.rxLet = value;\r\n    },\r\n    error: (error: Error) => {\r\n      // to have initial rendering lazy\r\n      if (!this.embeddedView) {\r\n        this.createEmbeddedView();\r\n      }\r\n      this.ViewContext.$error = true;\r\n    },\r\n    complete: () => {\r\n      // to have initial rendering lazy\r\n      if (!this.embeddedView) {\r\n        this.createEmbeddedView();\r\n      }\r\n      this.ViewContext.$complete = true;\r\n    }\r\n  };\r\n\r\n  static ngTemplateContextGuard<U>(\r\n    dir: LetDirective<U>,\r\n    ctx: unknown | null | undefined\r\n  ): ctx is LetViewContext<U> {\r\n    return true;\r\n  }\r\n\r\n  constructor(\r\n    cdRef: ChangeDetectorRef,\r\n    private readonly templateRef: TemplateRef<LetViewContext<U>>,\r\n    private readonly viewContainerRef: ViewContainerRef\r\n  ) {\r\n    this.strategies = getStrategies<U>({ cdRef });\r\n\r\n    this.renderAware = createRenderAware<U>({\r\n      strategies: this.strategies,\r\n      resetObserver: this.resetObserver,\r\n      updateObserver: this.updateObserver\r\n    });\r\n    this.renderAware.nextStrategy(DEFAULT_STRATEGY_NAME);\r\n  }\r\n\r\n  ngOnInit() {\r\n    this.subscription = this.renderAware.subscribe();\r\n  }\r\n\r\n  createEmbeddedView() {\r\n    this.embeddedView = this.viewContainerRef.createEmbeddedView(\r\n      this.templateRef,\r\n      this.ViewContext\r\n    );\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.subscription.unsubscribe();\r\n    this.viewContainerRef.clear();\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { LetDirective } from './let.directive';\r\n\r\nconst EXPORTED_DECLARATIONS = [LetDirective];\r\n\r\n@NgModule({\r\n  declarations: EXPORTED_DECLARATIONS,\r\n  exports: [EXPORTED_DECLARATIONS]\r\n})\r\nexport class LetModule {}\r\n","export const zonePatchedEvents = [\r\n  'scroll',\r\n  'mousedown',\r\n  'mouseenter',\r\n  'mouseleave',\r\n  'mousemove',\r\n  'mouseout',\r\n  'mouseover',\r\n  'mouseup',\r\n  'load',\r\n  'pointerup',\r\n  'change',\r\n  'blur',\r\n  'focus',\r\n  'click',\r\n  'contextmenu',\r\n  'drag',\r\n  'dragend',\r\n  'dragenter',\r\n  'dragleave',\r\n  'dragover',\r\n  'dragstart',\r\n  'drop',\r\n  'input'\r\n];\r\n","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  Input,\r\n  OnDestroy\r\n} from '@angular/core';\r\nimport { BehaviorSubject, Subscription } from 'rxjs';\r\nimport { tap } from 'rxjs/operators';\r\nimport { zonePatchedEvents } from './unpatch-event-list';\r\nimport { unpatchEventListener } from '../../core/utils/make-zone-less';\r\n\r\n/**\r\n * @Directive UnpatchEventsDirective\r\n *\r\n * @description\r\n *\r\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\r\n * of unnecessary renderings through zones `addEventListener` patches.\r\n * It can be used on any element you apply event bindings.\r\n *\r\n * The current way of binding events to the DOM is to use output bindings:\r\n *  ```html\r\n * <button (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\r\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\r\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\r\n *\r\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\r\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\r\n *\r\n * `unpatch` directive solves that problem.\r\n *\r\n * Included Features:\r\n *  - by default un-patch all registered listeners of the host it is applied on\r\n *  - un-patch only a specified set of registered event listeners\r\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\r\n *  - Not interfering with any logic executed by the registered callback\r\n *\r\n * @usageNotes\r\n *\r\n * The `unpatch` directive can be used like shown here:\r\n * ```html\r\n * <button [unoatch] (click)=\"triggerSomeMethod($event)\">click me</button>\r\n * <button [unoatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n// tslint:disable-next-line:directive-selector\r\n@Directive({ selector: '[unpatch]' })\r\nexport class UnpatchEventsDirective implements AfterViewInit, OnDestroy {\r\n  subscription = new Subscription();\r\n  events$ = new BehaviorSubject<string[]>(zonePatchedEvents);\r\n\r\n  @Input('unpatch')\r\n  set events(value: string[]) {\r\n    if (value && value.length > 0) {\r\n      this.events$.next(value);\r\n    } else {\r\n      this.events$.next(zonePatchedEvents);\r\n    }\r\n  }\r\n\r\n  reapplyEventListenersZoneUnPatched(events) {\r\n    events.forEach(ev => {\r\n      unpatchEventListener(this.el.nativeElement, ev);\r\n    });\r\n  }\r\n\r\n  constructor(private el: ElementRef) {}\r\n\r\n  ngOnDestroy() {\r\n    this.subscription.unsubscribe();\r\n  }\r\n\r\n  ngAfterViewInit(): void {\r\n    this.subscription = this.events$\r\n      .pipe(\r\n        tap(eventList => this.reapplyEventListenersZoneUnPatched(eventList))\r\n      )\r\n      .subscribe();\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { UnpatchEventsDirective } from './unpatch-events.directive';\r\n\r\nconst DECLARATIONS = [UnpatchEventsDirective];\r\n@NgModule({\r\n  declarations: DECLARATIONS,\r\n  exports: DECLARATIONS\r\n})\r\nexport class UnpatchEventsModule {}\r\n","import { NgModule } from '@angular/core';\r\n\r\nimport { LetModule } from './let';\r\nimport { PushModule } from './push';\r\nimport { UnpatchEventsModule } from './unpatch/events';\r\n\r\n@NgModule({\r\n  exports: [LetModule, PushModule, UnpatchEventsModule]\r\n})\r\nexport class TemplateModule {}\r\n","import { getGlobalThis } from './get-global-this';\r\n\r\n/**\r\n * envRunsIvy\r\n *\r\n * @description\r\n * Determines the used view engine of an Angular project is Ivy or not.\r\n * The check is done based on following table:\r\n * | render       | ViewEngine | ViewEngine | Ivy         | Ivy         |\r\n * | ------------ | ---------- | ---------- | ----------- | ----------- |\r\n * | **mode**     | prod       | dev        | prod        | dev         |\r\n * | **ng**       | present    | present    | `undefined` | present     |\r\n * | **ng.probe** | present    | present    | `undefined` | `undefined` |\r\n *\r\n *  So for Ivy we need to make sure that ng is undefined or,\r\n *  in case of dev environment, ng.probe is undefined.\r\n *\r\n * @return {boolean} - true if the used view engine is Ivy.\r\n *\r\n */\r\nexport function isViewEngineIvy(): boolean {\r\n  const ng: any = getGlobalThis().ng;\r\n\r\n  // Is the global ng object is unavailable?\r\n  // ng === undefined in Ivy production mode\r\n  // View Engine has the ng object both in development mode and production mode.\r\n  return (\r\n    ng === undefined ||\r\n    // in case we are in dev mode in ivy\r\n    // `probe` property is available on ng object we use View Engine.\r\n    ng.probe === undefined\r\n  );\r\n}\r\n","import { MonoTypeOperatorFunction, Observable } from 'rxjs';\r\nimport { tap } from 'rxjs/operators';\r\nimport { RenderStrategy } from '../../../core';\r\n\r\nexport function renderChange<T>(\r\n  strategy: RenderStrategy<T>\r\n): MonoTypeOperatorFunction<T> {\r\n  return (s: Observable<T>): Observable<T> => {\r\n    return s.pipe(\r\n      strategy.behavior,\r\n      tap(v => strategy.renderMethod())\r\n    );\r\n  };\r\n}\r\n","import { from, of, Observable, ObservableInput } from 'rxjs';\r\n\r\nexport function toObservableValue<T>(\r\n  p: ObservableInput<T> | undefined | null\r\n): Observable<T | undefined | null> {\r\n  // @ts-ignore\r\n  return p == null ? of(p) : from(p);\r\n}\r\n"]}